Research of An Association Rule Mining 
Algorithm Based on FP tree 
Li Juan 
Computer and Information Engineering Institute 
Jiangxi Agricultural University 
Nanchang, China 
Email: li juan.hb@163.com 
Abstract- Based on analyzing an association rule mining 
algorithm called FP tree. a new association rule mining 
algorithm called QFP was presented. Through scanning the 
database only once, the QFP algorithm can convert a transaction 
database into a QFP tree after data preprocessing, and then do 
the association rule mining of the tree. The QFP algorithm is 
more integrity than the FP ?rowth algorithm, and retain the 
complete information for mining frequent patterns; it will not 
destroy the long pattern of any transaction, and significantly 
reduce the non-relevant information. Experiments show that the 
QFP algorithm is more efficient if the aspect of time than the 
FP ?rowth algorithm. 
Keywords- Association rule mining; Frequent Pattern(FP}; 
FP Jrowth algorithm; QFP algorithm 
I. THE OUTLINE OF FP-TREE ALGORITHM 
In 2000, Han etc. proposed the FP _tree algorithm[l ], 
the algorithm is used in mining the frequent pattern of the 
Boolean rule from transaction database. Its entire excavation 
process is quite complex, but may be simply divided into two 
basic steps: First step, it constructs a FP tree using data in 
transaction database; Second step, it mines all frequent patterns 
from the FP tree, and establishes conveniently the association 
rule according to the frequent pattern and the profession 
background knowledge. 
Table 1. The transaction database D 
TID Item Frequent 1 item set after sorting 
TOOl f,a,c,g,i,m,p f,c,a,m,p 
TOO2 a,b,c,f,l f,c,a,b 
TOO3 b,f,h,m,p f,b,m,p 
T004 b,c,k,m,o c,b,m 
TOO5 a,f,c,e,n,p f,c,a,p 
978-1-4244-6585-9/10/$26.00 ©2010 IEEE 
559 
Ming De-ting 
Computer and Information Engineering Institute 
Jiangxi Agricultural University 
Nanchang, China 
Email: jxau_mdt@163.com 
The following is an example which shows that the FP _tree 
algorithm carries on the association rule excavation[2]. The 
database excavated is shown in Table 1, and it is supposed that 
the smallest support is min_sup=3. TID in table 1 lists the 
identifier of the transaction records. 
At first, the FP _tree algorithm scans the database, and 
obtains the support counting value of each item (the number 
which each item appears in database). The scanning result is 
f: 4, c: 4, a: 3, b: 3, m: 3, p: 3. The left side of the 
colon is the item's identifier; the right side of the colon is the 
support counting value of this item. Then delete the item whose 
support counting value is smaller than the min _sup from the 
scan result, and arrange various items which decreases 
progressively in order according to the item's support counting 
value, record the results in the table L, L=[ f: 4, c: 4, a: 
3, b: 3, m: 3, p: 3], the frequent 1 item set is shown 
as the 3rd row of Table 1 after the reorganization. 
Second step, construct the FP tree. It creates the root node 
whose symbol was null, and then scans the database once more, 
reads each transaction record in tum. If all items In a 
transaction appear in the table L, then rearrange them 
according to the order in the table L, and establish the 
corresponding branch in FP tree. The first record in Table 1 is 
TOOl, because its five items appear in the table L, therefore 
rearrange according to the order in the table L: {f,c,a,m,p} , 
and constructs a five node branch in FP tree <f: l .... c: l .... a: 1 .... 
m: l .... p: l>, fis connected to the root node, c is connected toJ, 
and a is to connected to a. Then read the second transaction 
record T002. Similarly, { a, b, c, f} in T002 appears in the table 
L, the arrangement according to the order in the table L is: f, c, 
a, b, then establish the corresponding branch in FP tree. 
Because the nodes f, c, a under the root node already 
existed, therefore only the node b was connected to the node a , 
and added the support counting values 1 on three nodes f, c, a. 
Thus, after scanning the entire database, constructed the FP 
tree which it corresponded. For the convenience of traversal 
the FP tree, a frequent item header table was created. The order 
of the element in the table was the same as that of the table L , 
each element of which had an indicator, aiming at the node 
which corresponded in FP tree. Finally the FP tree was formed 
in Figure 1. 
Third step, the FP _growth algorithm carries the excavation 
on the constructed FP tree. Regarding the FP tree shown in 
Figure 1, begin from the final element p in table L, found all 
the nodes whose symbol is p in FP _tree through its indicator, 
which appear in 3 branches. The nodes above the node p in 
these 3 branches constitute the condition pattern base of the 
node p, labeled by {(facm: l},(fca:l),(cbm: I)}, the value in 
right flank of the colon corresponds to the support counting 
value of the node p separately in three branches. The condition 
FP _tree of the node p is obtained from the condition pattern 
base of the node p, labeled by < c:3 >. That the node fhas not 
appeared in the condition FP _tree of the node p is because its 
support counting value is smaller than min_sup in the condition 
pattern base of the node p. Finally the node p combines with 
the node c which appears in the condition FP _tree, thus the 
frequent pattern is obtained: <cp: 3>, and other elements' 
frequent pattern from this table L may be obtained. The 
excavation result on FP tree was shown in Table 2. 
Frequent item header table 
Item Support counting value Head 
f 4 ? 
c 4 -
a 3 
... 
b 3 
... 
m 3 
\ 
\ 
P 3 
\ 
\ 
\ 
Figure 1. The FP tree corresponds to the database 
560 
TABLE 2. THE DEMONSTRATION OF EXCAVATING THE FP TREE 
condition Frequent 
Item the condition pauem base 
FP-tree paUem 
p {(facm:l },(fca:l),(cbm:1) } <c:3 > cp:3 
rn {(fca:l),(fb:l),(cb:l) } th th 
b {(fca:l),(f:l),(c:l) } th m 
a { (fc:3) } <fc:3 fa:3,ca:3, fc 
c { f:3 } <f:3 fc:3 
f th th m 
Although excavation efficiency of the association rule on 
the FP _growth algorithm is higher than that of the Aprioi 
algorithm[3], it still needs to scan twice transaction databases. 
The table L is obtained through the first scanning transaction 
database; the FP tree is constructed through the second 
scanning transaction database. Because the expense of 
scanning actual transaction database is very big, if the 
excavation algorithm can again reduce the number of times of 
scanning the transaction database on this foundation, then it 
can further effectively enhance the excavation efficiency of the 
association rule [4]. Therefore, we designed a fast association 
rule excavation algorithm called QFP. The QFP algorithm has 
two basic steps: first, scan the transaction database, the 
transaction database is transformed to the tree similar with the 
FP tree in the scarming process (which is called the QFP tree), 
and keep all related information between items in the database' ,
second, mining the QFP tree to find all possible association 
rules. Compared with the FP _growth algorithm, the QFP 
algorithm only needs to scan the transaction database once, so 
it can increase the time efficiency of mining association rules. 
II. RAPID ASSOCIA nON RULE MINING ALGORITHM ( QFP) 
A. Related definitions 
Definition I: Transaction database D, It's a database for 
storing transaction records. Every transaction record in the 
database has a unique identifier. A transaction record includes 
the order of all items involving the transaction. A simplified 
transaction database D is shown Table 3, where TOOl is the 
identifier of the first record in the database D, the transaction 
that TOO] corresponds to includes the items a, c, f, m, p, which 
are arranged in accordance with the order of the identifier. 
TABLE 3. TRANSACTION DATABASE D 
TID Original item set 
TOOl a,c,f,m,p 
TOO2 a,b,c,f, 
TOO3 b,f"m,p 
TOO4 b,c,m 
TOO5 a, c, f ,p 
Definition 2: The QFP tree is composed of an root node 
labeled null and several tree nodes, each of which node can 
form a sub-tree with n nodes(n=O, l, 2, ' .. ). When n is 
equal to 0, the node is called the leaf node. As the QFP tree 
represents the transaction database, the tree nodes are 
represented by the identifier of items in the database. Except 
the root node, each node Ii is composed of two fields, Ii.count 
and Ii.pointer, among which Ii.count is the number of the same 
items appearing on the node, and is labeled in the parentheses 
of the right side of the node's identifier Ii; Ii.pointer is the 
pointer pointing to its parent node. 
Definition 3:The path combining node C. It is an arbitrary 
combination of all nodes( excluding the root node) on the path 
from the leaf node to the root node null for the QFP tree. The 
value in the parentheses of the right side of the node identifier 
is the value count of the combination, and the value count is 
equal to Ii. count of the leaf node. 
Definition 4: Table TL is a pointer queue[5], each element 
in which points to the leaf node of the QFP tree, a pointer 
corresponds to the leaf node. 
Definition 5: Candidate set of frequent pattern CF[6].The 
element in the collection is C. 
B. The theory of the QFP algorithm 
The QFP algorithm is divided into constructing QFP tree 
and mining the QFP tree. 
]) Construct QFP tree 
First of all, create the tree's root node null of the QFP tree, 
then take the first record in the database D, and insert it into the 
QFP tree. The insertion process is: take the first item of the 
record, if the identifier of the root node is the same with that of 
561 
the child node in the QFP tree, then add 1 to the value count 
(count field) of the child node, Otherwise, create a new child 
node under the root node, and assign the identifier of the item 
as the identifier of the new child node; then take the inserted 
node as the root of the sub-tree, and insert the next item into 
the sub-tree by the above steps ; repeat until all items of the 
record have been inserted into the QFP tree, and complete a 
record insertion process. Then take a record from the database 
D, repeat the above record insertion process until all records in 
the database are inserted into the QFP tree. Thus, the 
transaction database D is transformed into the QFP tree after a 
scanning, and a path from the leaf node to the root node 
corresponds to one or more records, and retains the association 
information between items of the original records. In order to 
facilitate future mining association rules, in the process of 
building the tree, make the pointer of the table TL point to the 
leaf node in the QFP tree, one pointer corresponds to the leaf 
node. The database D shown in table 3 can be transformed into 
the QFP tree shown in figure 2 by the above processes, the 
value in parentheses of the right side of the node is hcount. 
Table TL 
1 
2 
3 
4 
5 
, 
, 
... ' 
I' 
, 
, 
"'" 
-
..... 
, 
.... 
; ------
.... - _ ... " 
I 
I 
Figure 2. Convert the database D into the QFP tree 
2) Mine the QFP tree 
Take the first element in the table TL, and obtain the leaf 
node which the element points to, and the path is formed from 
the leaf node to the root node null. Combine all nodes in the 
path (except the root node null), by definition 3, assign the 
identifier and the count of the combination. Then put all 
combination into the candidate frequent pattern set CF, If 
there already exists the same combination in the CF (i.e. the 
same identifier of the combination), then merge them. The 
operation of merging is: the identifier of the combination 
remains the same, and the value count is the sum of the two. 
After all the combinations on the path becoming the candidate 
frequent pattern set CF, amend the nodes on the path. The 
amendment process is: subtract the value count of the leaf node 
from the value count of all the nodes on the path. After that, if 
the leaf node on the path has the parent node which hasn't the 
other child node and the parent node is not a root node, let the 
pointer point to the parent node of the leaf node, and make it as 
a leaf node; do the same operation on a new path. Otherwise, 
delete the pointer from the table TL. 
Since then, take the next element in the table TL, repeat 
this process until all the elements in the table have been 
removed, and complete the processing of all leaf nodes in QFP 
tree. Finally, remove the combination whose value count is less 
than min_sup(the minimum support) in CF. In this way, the 
frequent patterns stay in CF, and construct out all the candidate 
association rules, and filter out the required association rules by 
the given value min_conf(minimum confidence). 
Here is the process of mining on the QFP tree(Figure 2). 
Find the leaf node p whose pointer points to the first 
element in the table TL, and obtain the path: p-m-c-a­
fa Combine on these five nodes to be {p, m} ( I ) , { p  , 
c} (I) , {p,  a} (I) , {p,  f}(I) , {m, c} (I) , {m, a} (I) , 
{m, f}(1) , {c,  a} (I) , {c,  f}(I) , {a,  f}(1) , {p,  m, 
c } (I), {p, c, a} (I), {p, c, f}(I), {p, a, f}(1), {p, 
m, f}(I), {p, m, a} (I), {m, c, a} (I), {m, c, f}(I), 
{c, a, f}(I), {m, a, f}(1), {p, c, a, m} (I), {p, c, 
a, f}(1) , { p, m, a, f}(1) , {m, c, a, f}(I) , {m, c, 
a, p} (I), {p, c, a, m, f}(I).CF is empty at this time, thus 
26 combinations enter directly into the CF. Then amend the 
nodes on the path by subtracting I from the value count of p, 
m, c, a, f. As the values count of the two nodes p, m is 0, while 
the value count of the parent node f of the node m is not 0, so 
delete the element in the table TL. So then, take the next 
element in table TL, repeat the process until left the last 
element in the table TL. The last pointer in table TL points to 
the leaf node p, and obtain various combinations on the four 
nodes p, c, f, a .Put the combinations into CF, and amend the 
nodes on the path . At this time because the values count of the 
four nodes p, f, a, c is 0, remove the pointer in the table TL. 
562 
Finally, remove the combinations whose count is less than 
min_sup (in this case min_sup = 3) from CF. Figure 2 shows 
the CF mining on the QFP tree: 
CF={ {c, a} (3) , {c, f}(3), {a, f}(3), {a, c, f } (3) } 
III. THE QFP ALGORITHM 
A. The theory of the QFP algorithm 
The pseudo code of QFP algorithm is as follows: 
Input: the transaction database D, min_sup 
Output: Frequent pattern set CF 
Steps: (1) Construct QFP tree 
Create the root node null; 
Open the database D; 
while(not EOF) 
{R= the current record; 
Call insert_tree(R, null); 
The pointer of the record pushed backward I; 
Procedure insert_tree(record, root_node) 
{while(record<> ¢) 
{first= the first item of the record; 
Remove the item from the record; 
if( existing the child node a in the root node whose identifier is 
first) 
a.count=a.count+ I: 
else 
{ Create the node a whose identifier is first; 
a.count=I; 
a.pointer points to the root node; 
} 
if(record= ¢ ) 
{ Remove the pointer which points to the other node on the 
path in the table TL; 
Create the pointer which points to the node a in the table TL; } 
} 
(2)Mining QFP tree(tree, TL) 
while(TL<> ¢) 
{ Take the first element in the table TL which points to the leaf 
node a; 
Combine the node a to the path whose root node is null ,the 
path is Cl' C2 "', Cm; 
for(i=l ;  i<=m; i++) 
{ Cj.count=a.count; 
The symbol Cj is assigned as the order arrangement of the 
nodes in this combination; 
if(CjECF) 
CF.Cj.count=CF.Cj.count+Cj.count; 
else 
Put Cj into the frequent pattern CF; } 
The value count of other nodes on this path subtracts the 
value count of the leaf node; 
if (the father node of the node a does not have other child nodes 
and also is not a root node) 
Modify the pointer which points to the node a in the table TL, 
it points to the parent node of the node a; 
else 
Remove the pointer which points to the node a in the table 
TL; } 
Remove the combination whose value count is less than 
min_sup in CF; 
B. Experimental result of the QFP algorithm 
To test the actual effect of the QFP algorithm, at the same 
software and hardware environment (P4 3GHz CPU, 2GMB 
RAM ,  250GB hardware, windows XP OS), we tested the 
QFP algorithm and FP _growth algorithm for mining 
association rules on a transaction database. The database has 
about 18,000 records, and the number of items set involving is 
about 200. Repeated tests showed that: the two algorithms 
mined out the same candidate frequent sets, and the mining 
speed of the QFP algorithm is improved by about 20%. The 
principle of the QFP algorithm is: as the transaction database 
increases, the time efficiency of the QFP algorithm will be 
further enhanced. 
When the transaction database is so large that the computer 
memory is difficult to save a QFP tree corresponding to the 
whole database, the database can be divided into several 
sub-databases according to the given conditions, and then the 
FP tree for each sub-database is constructed. Their respective 
path nodes of the QFP tree can be combined into a candidate 
general pattern. Finally process the candidate pattern again, and 
obtain all frequent patterns. Therefore, the QFP algorithm is 
563 
suitable specially to mine association rules on the large-scale 
business database. 
IV. CONCLUSION 
Because the excavated business database is very big, the 
algorithm's operating efficiency of mining association rules 
appears especially important. We have conducted the thorough 
research on the FP _growth algorithm, and have designed the 
association rule excavation algorithm called QFP. After the 
pretreatment of the data, without need to sort the items in 
business database according to the frequency descending 
sequence, this algorithm can transform the database into the 
QFP tree, and then carries on the excavation to the QFP tree. 
The experiment indicated that, the time efficiency of the QFP 
algorithm is higher than that of the FP _growth algorithm. As 
the input of the QFP algorithm is the same as that of the 
FP ?owth algorithm or the Apriori algorithm, therefore, the 
QFP algorithm may apply to any situation which is suitable for 
the FP _growth algorithm or the Apriori algorithm. 
REFERENCES 
[I] Grahne G . Efficient Mining of Constrained Correlated 
Sets[ C]. Proc. of 2000 Int. Conf. Data Engineering(ICDE . 
00), San Diego, 2000 : 512-52 1 
[2] Pasquier N, Taouil R, Bastide Y, et al. Generating A Condensed 
Representation for Association Rules[J]. Journal of Intelligent 
Information Systems, 2005,24(1):29-60. 
[3] Ceglar A, Roddick J F. Association Mining[J]. ACM Computing 
Surveys,2006,38(2): 1-42. 
[4] Lee Y C, Hong T P, Lin W Y. Mining Association Rules with Multiple 
Minimum Supports Using Maximum Constraints[J]. International 
Journal of Approximate Reasoning, 2005,40(1-2): 44-54. 
[5] Yang L. Pruning and Visualizing Generalized Association Rules in 
Parallel Coordinates[J]. IEEE Transaction on Knowledge and Data 
Engineering, 2005, 17( 1 ):60-70. 
[6] Song W, Yang B R, Xu Z Y. Index-Close Miner: An Improved 
Algorithm for Mining Frequent Closed ltemset[J]. Intelligent Data 
Analysis, 2008,12(4): 32 1-338. 
[7] Song W, Yang B R, Xu Z Y. Index-MaxMiner: A New Maximal 
Frequent Itemset Mining Algorithm[ J]. International Journal on 
Artificial Intelligence Tools, 2008, 17(2):303-320. 
