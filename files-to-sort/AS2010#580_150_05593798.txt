An Improved Template-based Method for Mining
Association Rules from Defect Repositories
Ning Li, Zhanhuai Li and Xia Li
School of Computer Science and Technology
Northwestern Polytechnical University
Xi’an, China
Email: {lining, lizhh, lixia}@nwpu.edu.cn
Abstract—Frequent pattern mining from defect repositories
has started playing an important role in software defect detection
and analysis[1]. In this paper, we present a new improved
template-based method to generate association rules from defect
repositories. We aim to provide manager and tester with more
ef?cient method of generating rules. The improved method
optimizes the generation using rule templates ?rstly, then reduces
unnecessary rule generation by the theorems described in Section
III-A. The advantages of the improved method are validated by
an experiment based on 1860 defect reports. The experimental
results show the improved template-based method can signi?-
cantly reduce the total number of the rules, and shorten the run
time. The pruned association rule set makes it easier to ?nd the
interesting rules.
Index Terms—Association rules, Template, Software defect,
Black-box testing
I. INTRODUCTION
Software defect repositories contain valuable information
which is helpful to improve the process of software de-
velopment. Therefore, frequent pattern mining from defect
repositories has started playing an important role in software
defect detection and analysis[1]. In frequent pattern mining,
association rules mining is an important mining task.
Association rules mining was ?rst proposed by Agrawal
et al.[2]. The mining task is to discover the relations be-
tween items in large databases. Since the ?rst proposal of
this new data mining task and its associated ef?cient mining
algorithms, there have been hundreds of follow-up research
publications[1]. Thousands of rules may be found if using
the classical algorithms without any constraints, but a par-
ticular user is interested in only a small subset of them.
Constraint-based mining, which refers to mining only the
rules that satisfy user-speci?ed constraints, can reduce the
numbers of interesting rules and improve the ef?ciency of
mining rules. Constraint-based mining can include: knowledge
type constraints, data constraints, dimension/level constraints,
interestingness constraints and rule constraints(template-based
constraints)[3]. Literature [4] describes the rule templates in
detail.
In our another related literature[5], we mined the association
rules with basic Apriori algorithm from defects detected by
black-box testing (called black-box defect). In this paper,
we propose an improved template-based method for mining
Supported by the National Science Foundation of China No.60970070.
association rules from software defect repositories. The exper-
imental results show that the improved method can reduce the
number of rules effectively, and has a better performance than
basic Apriori algorithm.
This paper is organized as follows. In Section II, we
introduce the background of template-based association rules
mining and rule templates in software defect repositories.
Section III describes our improved method for generating
interesting association rules. In Section IV, we present the
experiment about the improved method. Finally Section V
concludes the paper.
II. BACKGROUND
A. Frequent Itemsets and Association Rules
Let I = {i1, i2, ..., ik} be a set of items. A subset of I
is called an itemset or a k-itemset if it contains k items. Let
D = {d1, d2, ..., dm} be a set of database transactions where
each transaction T is a set of items such that T ? I . Let A be
a set of items. A transaction T is said to contain A if and only
if A ? T . Frequent itemset A means the support (supp(A))
is greater than user-speci?ed minimum support threshold. And
supp(A) is de?ned as the probability of transactions in the D
which contains A.
An association rule is an implication of the form A ? B,
where A ? I , B ? I , and A?B = ?. The interestingness of an
association rule is usually measured by support and con?dence,
which respectively re?ect the usefulness and certainty of the
rule. The support supp(A ? B) is the percentage of transac-
tions in D that contain A
?
B (both A and B). This is taken to
be the probability, P(A
?
B). The con?dence conf(A ? B)
is the percentage of transactions in D containing A that also
contain B. This is taken to be the conditional probability,
P(B|A). That is,
supp(A ? B) = P (A
?
B) (1)
conf(A ? B) = P (B|A) = supp(A ? B)
supp(A)
(2)
Rules that satisfy both a minimum support threshold (min-
sup) and a minimum con?dence threshold (minconf) are called
strong association rules. The following example is a typical
association rule.
978-1-4244-6005-2/10/$26.00 ©2010 IEEE 
The 5th International Conference on
Computer Science & Education
Hefei, China. August 24–27, 2010
 1796 
ThP14.1
Example 1. In a large database of supermarket transactions,
an association rule is:
milk ? bread [supp = 30%, conf = 85%].
The support of 30% means that only 30% of the customers
have purchased both milk and bread. The con?dence of 85%
means that 85% of the customers who have purchased milk,
also have purchased bread.
In general, association rules mining can be viewed as a
two-step process:
1) Find all frequent itemsets: By de?nition, each of these
itemsets will occur at least as frequently as a predeter-
mined minimum support.
2) Generate strong association rules from the frequent item-
sets: By de?nition, these rules must satisfy minimum
support and minimum con?dence.
In this paper, we mainly focus on the second step. The
frequent itemsets of the ?rst step can be found by several
algorithms, such as basic Apriori algorithm[6].
B. Template-based Association Rules Mining
Template-based mining means user speci?es the form of
rules to be mined(called rule template). Rule templates may
include the maximum or minimum number of predicates that
can occur in the rule antecedent or consequent, or as relation-
ships among attributes, attribute values, and/or aggregates.
Rule templates are expressions like
A1, ..., Ak ? Ak+1
where each Ai is either an attribute name, a class name or an
expression C+ or C?, where C is a class name. Here C+ and
C* correspond to one or more and zero or more instances of
the class C respectively. If the rule B1, ..., Bh ? Bh+1 can
be considered to be an instance of the template A1, ..., Ak ?
Ak+1, we call rule B1, ..., Bh ? Bh+1 matches rule template
A1, ..., Ak ? Ak+1.
Example 2. In a database of software defect, a defect may
be associated with one or more function modules. If tester is
interested in function “Statistics”. In particular, it would be
interesting to know the associations where “Statistics” is one
the right hand side and there is another function on the left
hand side, such as
Monthly Data ? Statistics
Such rules match the pattern
Any Function+ ? Statistics
C. Rule Templates in Software Defect Repositories
Software defect reports are usually described in natural
language, which include tester, test date, priority, summary,
detail description, steps to reproduce and some other related
attach ?les, etc[7]. It can provide manager decision information
to improve the process of software development by mining
association rules from defect repositories. We only focus on the
black-box defect in this paper. We classify the original defects
according to ODC-BD(Orthogonal Defect Classi?cation for
Black-box Defect)[8], and then retain tester and test date of
the original defect reports. In this paper, we take the following
typical rule templates as examples to show our improved
template-based method.
Template 1.
Each Tester ? Any DefectType?
The template aims to know which kinds of defects are often
found by each tester. From the matched rules, managers can
see everyone’s testing ability and it is helpful to assign test
resources. Furthermore, if adding time constraint, managers
can evaluate tester’s work according to different period. For
example, an instance is:
TesterA ? 212 [supp = 20%, conf = 90%].
Here “212” is the line number of ODC-BD’s defect type[8],
and it refers to “Message format and content error”. The above
rule can show 90% of defects which detected by TesterA are
simple error as “Message format and content error”.
Template 2.
AnyDefectType ? (Condition) ?
AnyDefectType+ (Result)
The description of one defect usually includes occurred con-
dition (data or operation) and result(phenomenon). Therefore,
we distinguish whether a defect type is a condition or a result
for a certain defect. Template 2 can show which kinds of data
or operations easily lead to which kinds of defect phenomenon.
In the instance of Template 2, “C***” means a defect type is
a condition, and “R***” means a defect type is a result. For
example, an instance is:
C68, C106 ? R209, R221 [supp = 2%, conf = 100%].
Here “68” means “Boundary value”, “106” means “Name
of path/folder/?le”, “209” means “Prompt/Error message is
wrong” and “221” means “GUI display error”. The rule
indicates when testing the name of path/folder/?le with bound-
ary value, prompt/error message and GUI display are often
incorrect. It reminds tester to use boundary value when testing
the name of path/folder/?le.
III. IMPROVED METHOD BASED ON RULE TEMPLATES
A. Optimization by Reducing Unnecessary Rule Generation
To optimize the rule generation, we propose the following
theorems. The theorems indicate that in what conditions we can
reduce unnecessary rule generation, and in what conditions we
can not.
Theorem 1. Let X , Y be itemset, and Y 1 be a subset of Y .
If rule X ? Y 1 is not strong, then X ? Y is certainly not
strong.
 1797 
ThP14.1
Proof: By the de?nition of support, the support of a subset
is certainly greater than or equals the support of it’s superset,
we have
supp(X ? Y 1) ? supp(X ? Y )
So that,
conf(X ? Y 1) = supp(X ? Y 1)
supp(X)
? supp(X ? Y )
supp(X)
= conf(X ? Y )
Since rule X ? Y 1 is not strong, we have
conf(X ? Y 1) ? minconf
and
conf(X ? Y ) ? conf(X ? Y 1) ? minconf
Thus rule X ? Y is certainly not strong.
Theorem 2. Let X , Y be itemset, and X1 be a subset of X .
Regardless of whether rule X1 ? Y is strong, the generation
of rule X ? Y can not be optimized.
Proof: By the de?nition of support, the support of a subset
is certainly greater than or equals the support of it’s superset,
so we have
supp(X1) ? supp(X)
and
supp(X1 ? Y ) ? supp(X ? Y )
The con?dence of rule (X1 ? Y ) and (X ? Y ) is de?ned
as follows:
conf(X1 ? Y ) = supp(X1 ? Y )
supp(X1)
conf(X ? Y ) = supp(X ? Y )
supp(X)
Therefore the size of conf(X1 ? Y ) ? conf(X ? Y ) is
uncertain. Thus the generation of rule X ? Y can not be
optimized, and it is uncertain whether rule X ? Y is strong
until the conf(X ? Y ) is calculated.
B. Method and Algorithm Description
In this section, we present the improved method based on
rule templates. The method is divided into three steps.
• Step1: Find all frequent itemsets by any algorithm. Here
we use the classical Apriori algorithm to ?nd them.
• Step2: Put proper items into two different sets(e.g.
antecedentSet and consequentSet) according to the left
and right hand side of the speci?ed template. Thus, this
step optimizes the rule generation with rule templates.
• Step3: Combine every nonempty subset of the
antecedentSet and the consequentSet to generate
rules. During combination, apply the theorems presented
in Section III-A to reduce the unnecessary rule generation.
The Apriori algorithm in step1 which generates all frequent
itemsets can be found in[6], so Algorithm 1 only contains the
step2 and step3 in detail.
Input: all frequent itemsets: freqItemSet,
minimum con?dence: minconf
Output: strong association rules set: ruleSet
1 delete frequent 1-itemset;
2 for each frequent itemset: l in freqItemSet do
// Optimize by rule templates
3 antecedentSet = ?;
4 consequentSet = ?;
5 for each item: i in l do
6 if i matches the left of rule template then
7 add i into antecedentSet;
8 else if i matches the right of rule template then
9 add i into consequentSet;
10 else
11 continue;
12 end
13 end
14 generate all nonempty subsets of antecedentSet;
15 generate all nonempty subsets of consequentSet;
// Optimize by theorems
16 for each subset: setA in antecedentSet do
17 weakItemSet = ?;
18 for each subset: setB in consequentSet do
19 for each weakItem ? weakItemSet;
20 if setB is not superset of weakItem then
21 generate rule setA ? setB;
22 calculate the conf(conf ) of
setA ? setB;
23 if conf ? minconf then
24 add setA ? setB into ruleSet;
25 else
26 add setB into weakItemSet;
27 end
28 end
29 end
30 end
31 end
32 return ruleSet;
Algorithm 1: Improved Algorithm
In addition, to compare with our improved algorithm, we
also implement the Apriori rule generation algorithm described
in [3].
C. Example
Let’s try an example based on Template 2 described in
Section II-C. Suppose l = {C68, C107, R209, R221} is a
frequent 4-itemset. What are the association rules that can be
generated from l?
 1798 
ThP14.1
According to the Template 2, the left of the rule should
contain “C***”, and the right of it should contain “R***”,
thus antecedentSet is {C68, C106} and consequentSet is
{R209, R221}. The nonempty of antecedentSet are {C68},
{C106} and {C68, C106}. The nonempty of consequentSet
are {R209}, {R221} and {R209, R221}. The steps of
generating rules are listed in Table I, and let minconf be 60%.
TABLE I
EXAMPLE OF RULE GENERATION BY ALGORITHM 1
Rule Conf weakItemSet ruleSet
{C68} ? {R209} 50% {R209} ×
{C68} ? {R221} 60% {R209} ?
{C68} ? {R209, R221} ? ? ?
{C106} ? {R209} 72% ? ?
{C106} ? {R221} 23% {R221} ×
{C106} ? {R209, R221} ? ? ?
{C68, C106} ? {R209} 90% ? ?
{C68, C106} ? {R221} 75% ? ?
{C68, C106} ? {R209, R221} 75% ? ?
For example, due to the con?dence of ({C68} ? {R209})
is smaller than minconf(60%), the ?rst rule should not be
included in “ruleSet”, thus the value of column “ruleSet” is
“×” and {R209} is added into weakItemSet. The con?dence
of the second rule is larger than minconf, so {C68} ? {R221}
should be add into “ruleSet” with “
?
”. Then the right hand
side of third rule is a superset of {R209} in weakItemSet,
so the rule is reduced according to Algorithm 1 with “?”. For
this example, the ?nal output “ruleSet” is {{C68 ? R221},
{C106 ? R209}, {C68, C106 ? R209}, {C68, C106 ?
R221} and {C68, C106 ? R209, R221}}.
IV. EXPERIMENT
To show Algorithm 1 can improve the generation of asso-
ciation rule , we set up the following experiment.
We take Template 2 described in Section II-C as our target
rule template and use the classi?cation result data in [8] as our
experimental data. The original defect data include 1660 black-
box defect reports distributed in 39 industrial projects and 200
black-box defect reports of open source projects(Eclipse and
Firefox).
All the experiments are performed on a 2.40GHz Intel core2
duo PC machine with 2GB memory, running on Microsoft
Windows 7. All the programs are written in Java. Fig. 1
compares the total number of association rules generated by
Algorithm 1 and Apriori Algorithm. Fig. 1 shows that the
improved template-based algorithm can signi?cantly reduce
the total number of association rules. Therefore user can ?nd
the interesting rules more easily by this method.
Another comparison is run time comparison between Algo-
rithm 1 and Apriori Algorithm. Fig. 2 shows that the improved
template-based algorithm has a better performance than basic
Apriori Algorithm in generating interesting rules.
V. CONCLUSION
In this paper we present a new improved template-based
method to generate the association rules. This method is a
Fig. 1. Number of Rules Comparison of Algorithm 1 and Apriori Algorithm
Fig. 2. Run Time Comparison of Algorithm 1 and Apriori Algorithm
two step optimization. Firstly, optimize the generation using
rule templates which are speci?ed according to user’s special
constraints. Then reduce unnecessary rule generation by the
theorems presented in Section III-A. To validate the improved
method, we apply it in mining rules from software black-box
defect repositories. The empirical study shows the improved
template-based method can reduce the total number of the
rules and the run time comparing with Apriori algorithm. The
mined interesting rules is very helpful for software manager
and tester.
REFERENCES
[1] J. Han, H. Cheng, D. Xin, and X. Yan, “Frequent pattern mining: current
status and future directions,” Data Mining and Knowledge Discovery, vol.
15, no. 1, pp. 55-86, 2007.
[2] R. Agrawal, T. Imieliski, and A. Swami, “Mining association rules
between sets of items in large databases,” Proceedings of the 1993 ACM
SIGMOD international conference on Management of data, Washington,
D.C., United States, 1993, pp. 207-216.
[3] J. Han and M. Kamber, Data Mining: Concepts and Techniques (2nd
edition): Morgan, 2006.
[4] M. Klemettinen, H. Mannila, P. Ronkainen, H. Toivonen, and A. I.
Verkamo, ”Finding interesting rules from large sets of discovered as-
sociation rules,” Proceedings of the third international conference on
Information and knowledge management, Gaithersburg, Maryland, United
States, 1994, pp. 401-407.
[5] N. Li, Z. Li, and L. Zhang, “Mining Frequent Patterns from Software
Defect Repositories for Black-box Testing,” Proceedings of the 2nd
International Workshop Intelligent System and Applications(ISA2010),
Wuhan, China, 2010, pp. 522-525
[6] R. Agrawal, and R. Srikant, “Fast Algorithms for Mining Association
Rules in Large Databases,”Proceedings of the 20th International Confer-
ence on Very Large Data Bases, 1994, pp. 487-499.
[7] N. Li, and Z. Li, “Overview of Software Defect Data Processing Re-
search,” Computer Science, 2009,36(8), pp. 21-25,78 (in Chinese with
English abstract)
[8] N. Li, Z. Li, and X. Sun, “Classi?cation of Software Defect Detected by
Black-box Testing: An Empirical Study,” unpublished.
 1799 
ThP14.1
