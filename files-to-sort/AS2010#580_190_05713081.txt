THE PREDICTION OF SOFTWARE AGING TREND BASED ON USER INTENTION
Jun Guo 1, Ying Ju 2,Yunsheng Wang,Xianli Li,Bin Zhang3
College of Information Science and Engineering, Northeastern University, Shenyang, China. 
1 guojun@ise.neu.edu.cn,215840055963@163.com,3zhangbin@ise.neu.edu.cn 
ABSTRACT
Owing to the limitation of traditional software aging trend 
prediction method that based on time and based on 
measurement in dealing with sudden large scale concurrent 
questions, this paper proposes a new software aging trend 
prediction method which is based on user intention. This 
method predicts the trend of software aging according to the 
quantity of user requests for each components during the 
moment of system operation, and the software aging damage 
with each component is requested once.The experiment 
indicates, compared with the measurement  method, this 
method has highter accuracy in dealing with sudden large 
scale concurrent questions. 
Index Terms—software aging,user intention prediction,
cumulation damage, multivariate linear regression analysis , 
association rule mining 
1. INTRODUCTION 
Recent studies and extensive data indicate that the system 
failure occurs mostly due to software defects. With software 
working, system resources gradual exhaust or run errors 
gradual accumulate, they both cause system performance 
continues to decline and even hang down. This 
phenomenon is known as software aging[1].The reason why 
it happens is that, in the long-term continuous operation, 
software exists the occupation and leak in system memory, 
not released file lock, the data is not updated in time, storage 
space debrisa and the accumulation of rounding errors, 
etc.[1]. This phenomenon seriously threats the software 
reliability, especially if the server which faces extensive 
visits and large amount of data was down caused by aging, 
it wouldn’t respond to user requests and make significant 
losses. In order to resolve this problem, software 
rejuvenation is introduced. This kind of "software restore" 
technology is formally proposed in [2] by Y. Huang who 
come from AT&T Bell Laboratory. Software rejuvenation is a 
preventive measure designed to prevent accidental failure. 
Simply, it terminates the running of program when the 
performance of software declines to a certain degree, restarts 
the system to clean up its internal state (such as collect 
garbage, update the operating system kernel tables, re-
initialize  the internal data structure, etc .)  and release of  the  
operating system resources, so that performance of software 
could be restored[2]. The key of software rejuvenation 
technique is to find the optimal rejuvenation time by the 
prediction of software aging trend. According to previous 
researches, we can group the prediction of software aging 
trend into two basic ideas. One is time-based[2], that is to 
establish mathematical model based on state of software 
system, and then to predict by mathematical method. S.Garg 
etc. [3] propose a most perfect comprehensive model about 
time-based. Another is measurement-based[4], that is to 
predict by main parameters which are monitored during 
actual running process . In [4], S.Garg proposes the key 
parameter is memory usage which is likely to lead to software 
aging. In addition, K. Vaidyanathathan etc. [5] take the 
system load into account, they think the rate of resources 
consumption as not only the function of time but also load. 
It can be seen through the above description, time-
based approach is easy to accomplish, but it does not 
measure the current state of the software, therefore it applies 
only to the system which has small changes in visiting and 
loading. The measurement-based method monitors the 
condition of running system to predict, but in unknow 
circumstance such as  sudden large scale concurrent,
because of unexpected factors, it is difficult to predict based 
on current data. Therefore, this paper proposes a new 
software aging trend prediction method which is based on 
user intention. The reason why system aging is that various 
components effect, each component generates a little aging 
damage after it is requested once, according to the predicted 
result of  user intention, all the damages are accumulated to 
get the amount of damage of whole system. In this paper, 
firstly, use the method of multiple linear regression to
compute the aging damage coming from various components 
which are requested once, and then predict the users  access 
amount in "next moment",finally, accumulate them to predict 
the software aging trend. 
2. EXTRACT THE AGING DAMAGE OF COMPONENTS 
Software aging is an process that error continuously
accumulates, it usually shows through the loss of system 

___________________________________ 
978-1-4244-8886-5/10/$26.00 ©2010 IEEE  
  
resources, however, it does not immediately cause system 
failure, instead of gradual deterioration even failure. 
Therefore, through the asymptotic loss of system resources, 
it can judge if the software exists aging problem or not. The 
use of system resources includes two parts: the normal 
running and the software aging damage. The normal running 
part is varied with system load, while the damage part 
appears an obvious upward or downward trend. Figure 1 
shows a collection of system available memory data, it is 
observed that the available memory is random and rapid 
changing, that is because the load is gradually changed 
during system operation, but among the entire process, it 
appears an obvious downward trend, which is caused by the 
software aging damage. To analyze the process of software 
aging, firstly need to extract the software aging damage part 
from the normal running part[6]. 
Fig. 1 system available memory 
The next step is to calculate the amount of damage after 
each component is requested once according to the overall 
damage. The whole system aging is the result of various 
components combined effect, this process could be seen as 
multiple independent variables affect a dependent variable,
so we can solve this problem by multivariate linear 
regression analysis  method[7]. Take the damage of the 
whole system as dependent various and the damage after 
each component is requested once as independent various. 
Comput the influence factors(the coefficient of independent 
various) according to the history records, then to predic. In 
addition, physical memory leak is an important factor leading 
to software aging, this paper takes  memory as research 
object. For illustration, make the following definition: 
Definition 1 Set (Y,T)=((y1,t1),(y2,t2),(y3,t3),…,(yn,tn)) as the 
consumption of memory during interval time (t i-ti-1,
i=1,2,…,n).  
Definition 2 Set (S1,S2, …,Sk) as the components deployed 
in the server, (x1,x2, …,xk) as the amount of each 
component is called, in the k+1 dimensional sequence 
(?0? ?1? ?2?…,?k), when k = 1,2, ..., k, it is the 
consumption of each component is called once, when k = 
0 , it is the basic consumption of memory during the 
server running.
Definition 3 Set ?=(?1??2?…,?n)as the random error, and 
??N(0??2).
Take the n group of observed value (yi?xi1,xi2, …,xik) i=1?
2…n,as the equation set:
1 0 1 11 2 12 1 1
2 0 1 21 2 22 2 2
0 1 1 2 2
k k
k k
n n n k nk n
y x x x
y x x x
y x x x
    
    
    
     


     




     
	
Where yi(i=1,2,…,n) is the consumption of memory 
resources in some time, it is measurable, xij(i=1,2?…,n 
j=1,2,…,k) is the  amount of each component is requested
form i-1 to i period, it is recordable too. ? is the consumption 
of the memory caused by each component is called once and 
? is the random error, the two values are waiting tested. The 
above equation can be written in matrix form in formula 1:
Y=X?+?                                           (1) 
Where
11 12 1
21 22 2
1 2
1
1
1
k
k
n n nk
x x x
x x x
X
x x x

 
 
 

 
 
 
, Y=(y1,y2,…,yn)T,
?=(?1??2?…,?n)T, ?=(?0??1??2?…,?k)T .
We can get ? by OLS. The solution of formular 1 is: 
                                         
' 1ˆ ( ) 'X X X Y  (2)
When yi=?0+?1xi1+?2xi2+…+?kxik+?i, define residual error ei as 
the estimation of random error ?(the form of ei defined in 
formular 3), so the estimation of ?2 is SSE, it is defined in 
formular 4. 
0 1 1 2 2i i i i k ike y x x x   
   
      (3)
Qe=e12+e22+…en2                                                         (4)
3. THE ACCUMULATION OF SYSTEM AGING DAMAGE  
In order to predict the consumption of system memory 
caused by aging while the call number of components are
1 2( , , )kx x x x , it uses of the formula 5:
0 1 1 2 2 k ky x x x                        (5)
in formula 5, ? and ? are the estimated value in section 2, so 
now, the key is to seek for the number of call for various 
components in "next time" , it is 1 2( , , )kx x x x . 
The services usually exsit in the form of components in 
web site, there are various relationships information between 
components and components, and they are closely 
contacted with user access pattern. When a user visits a 
web site, it records the access log, the accumulated access 
logs are the best object of data mining[8]. By mining these 
logs, user access patterns can be found. For example, 
Association Rule Mining can get related information 
between components through history use access, make use 
of the information to predict the future situation of the user 
access real-time. 

3.1Basic Concepts  
In order to analyze the association rule between 
components, the formal definition is following:  
Definition 4 (Component Set) All of the components 
appearing in the web site are expressed as  p=(p1, p2, …, pk),
the web pages which execute same function form a 
component.  
Definition 5 (Item Sets) A series of components which are 
visited by someone user are called the item set ui, ui?
p. Define the number of items as the size of item sets. 
Definition 6 The support S(pi) of pi?p is the frequency of 
components appear.The support S(pi, pj) of pi?pj is the 
frequency of components combination appear. 
Definition 7 The confidence of rules pi=>pj is
S p p
(p p )
S p
i j
i j
i
C

 
? ?
? ? ,it means the probabilityof 
access the component pj after pi
Definition 8 The importance of rules pi=>pj is 
I(p =>p ) ln[ (p |p ) / (p |not p )]i j j i j iC C  , it means the 
effectiveness of the rules, if the value is the higher, the 
rule is more effective.  
3.2 Mining User Intention by Association Rule 
First of all, through the user access logs we can get a 
transaction database, such as Table 1.These data describe a 
series of components accessed by the users, for instance, T1
user accesses to the p1, p2 and p5 components. Take these 
records as historical data, through a large number of them to
mine the relation information between components. 
Table 1 user access record 
user component user component
T1 p1 p2 p5 T6 p2 p3
T2 p2 p4 T7 p1 p3
T3 p2 p3 T8 p1 p2 p3 p5
T4 p1 p2 p4 T9 p1 p2 p3
T5 p1 p3
Then, according to the above historical data, us e 
association rule mining algorithm to get the possibility that  
is similar to user access pj after access pi. There are two key 
steps in association rule mining algorithm, the first  is how to 
generate frequent itemsets, the second is how to generate 
association rules based on frequent itemsets. Apriori[9] is a 
classical association rule algorithm, this paper uses it to get 
the posibility of user accesses pj after pi. The basic idea of 
Apriori algorithm could be found in[10], here is not 
described in detail. 
Finally,build the confidence matrix Ck×k(fumula6)
according to the confidence computed through Apriori 
algorithm . where Cij is the confidence of accessing pj after 
pi. If it is known that the amount of user request for each 
components at the current time is ? = (?1, ?2, ..., ?k), the total 
amount of user request for component pj at the next time is 
expressed as fumula 7.
11 12 1
21 22 2
1 2
k
k
k k
k k kk
C C C
C C C
C
C C C


 
 
 

 
 
  (6) 
1
k
j i ij
i
P C



(7) 
Similarly, the total amount (P1,P2, …,Pj) of user request for 
other components is easy to solve. P=(P1,P2, …,Pj) is equal 
to 1 2( , , , )kx x x x . 
3.3Accumulating Damage Model 
The memory damage of the whole system is the 
accumulation of all the components damages coming from 
the process of  requestion. It is  known the damage while 
each component is called once and the amount of calling at 
the next time, it could  predict the remain of system memory 
at the next time. The accumulating damage model can be 
expressed in the form of formula 5. ?0??1??2?…,?k and ?
are estimated in section 2 , 1 2( , , , )kx x x x is estimated in 
section 3. 
4. EXPERIMENT 
The research is accomplished under the operation of 
Microsoft Windows XP?configurate a Tomcat server which 
is saved 5 components, these components are compiled in 
JAVA. In order to simulate the phenomenon of software 
aging caused by memory leak, the basic function of these
components is to create an object which occupies a certain 
amount of memory as well as doesn’t release before 
restarting the server. In this way, when each component is 
called, it produces a certain degree of memory leaks. By 
using pressure measurement tool provided by Loadrunner, 
virtual users are created to ask for these components, as
described in Table 2, the result is demonstrated in figure 2.
The purple line is the actual running result of the 
system,the green line is the result of software aging trend 
prediction based on user intention and the red line is the 
result of measurement-based. From this picture, it can be 
seen that when the change of access amount is not 
significant,the two prediction methods both are near to the 
real value. However,when the change of access amount is 
dramatical, it is similar to the moment of 10 minutes, the 
measurement-based method can’t adapt to change of access 
amount, it predicts the software aging trend according to the 
outdated state. Similarly ,when the moment of 14 minutes, 

the access amount is dramatically increasing from 0 to 220, 
the measurement-based method makes an inaccurate 
prediction too. On the contrary, whether the change of 
access amount is significant or not, the method based on 
user intention could accurately predic the software aging 
trend. So ,it can be concluded that, compared with the 
measurement method, this method has highter accuracy in 
dealing with sudden large scale concurrent questions. 
Table 2 request data 
Fig. 2  prediction result
5. SUMMARY 
Software aging of the system is due to the call and 
transformation of various components , each component will 
generate a certain of damage after calling, the more the 
amount of visiting, the greater the degree of aging. This 
paper calculats the damage of each component is requested 
once according to the history record by multiple linear 
regression, and then predict the amount of visiting for the 
next time by association rule mining, finally, accumulate the 
amount of damage from concurrent request to get the total 
amount of damage of entire system during certain period.
Using it to predic the software aging trend. The experiment 
illustrats that this method of considering the system loading 
is more precise than measurement-based method in solving 
the large concurrent problem.  
6. REFERENCES
[1]Castelli V, Harper RE, Heidelberger P, etc. Proactive 
Management of Software Aging[J].IBM Journal of Reaserch 
& Development,2001,45(2):3ll? 332. 
[2]Huang Y,Kintala C,Kolettis N,etc.Software Rejuvenation: 
Analysis,Module and Application[C].Proceedings of the 25th
Symposium on Fault Tolerant Computer Systems, Pasadena, 
CA,1995:381—390?
[3]Grag S,Puliafito A,Telek M,Trivedi K S.Analysis of 
Preventive Maintenance in Transactions Based Software 
Systems.IEEE Transactions on Computer,Jan,1998. 
[4]Garg S,van Moorsel A,Vaidyanathan K,Trivedi K S.A 
Methodology for Detection and Estimation of Software 
Aging.In:Intl.Symp.on Software Reliability Engineering, 
ISSRE 1998,Nov 1998. 
[5]Vaidyanathan K,Trivedi K S.A Measurement-Based 
Model for Estimation of Software Aging in Operational 
Software Systems.In:Intl.Symp.on Software Reliability 
Engineering, ISSRE 1999,Nov 1999. 
[6]Jiang L e-t i an ,Xu Guo-z hi ,Z hou L i n g-l i n g. 
Abstraction of Software Aging Trend Ba sed on Robust 
Locally Weighted Regre ssion Algorithm[J]. Journal Of 
Shanghai Jiaotong University,2006,40(11):1951-1954.
[7] Wang Hui-wen, Ye Ming, Gilbert Saporta. Classification 
for Multiple Linear Regression Methods[J].Journal of 
System Simulation,2009(22):7048-7056.
[8]RUAN Guang-ce? Ah-HwweYu.Heuristic Web mining 
algorithm based on interesting degree strategy.Computer 
Engineering and Applications?2009?45?35??148-150.
[9]Agrawal R, Imielinski T, Swami A. Mining association 
rules between sets of items in large databases .Proceedings 
of the 1993 ACM SIGMOD International Conference on 
Management of Data. New York, NY, USA: ACM Press, 
1993:207-216 . 
[10]Jiawei Han?Micheline Kamber. Data Mining concetpts 
and techniques.China: Mechine Press,2007?137-138.
ACKNOWLEDGMENT 
We would like to thank the support of the project “National 
Hi-tech Research and Development Project (863) of China” 
(2009AA01Z122). 

