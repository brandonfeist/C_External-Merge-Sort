  153
A Multi-objective Scheme to Hide Sequential Patterns 
 
Babak Rahbarinia 
Computer Engineering Department 
 Islamic Azad University, Science and Research Branch 
Tehran, Iran 
babak.rhbrn@yahoo.com 
Hamid R. Arabnia 
Computer Science Department 
Georgia University 
Georgia, USA 
hra@cs.uga.edu 
Mir Mohsen Pedram 
Computer Engineering Department, Faculty of Eng.  
Tarbiat Moallem University  
Karaj/Tehran, Iran  
pedram@tmu.ac.ir 
Zohreh Alavi 
Computer Engineering Department, Faculty of Eng.  
Tarbiat Moallem University  
Karaj/Tehran, Iran  
zohreh.alavi@gmail.com 
 
 
Abstract—Notwithstanding the fact that data mining and 
particularly sequence mining have come to the help of 
database proprietors and experts in variety of fields by 
extracting the hidden knowledge in their raw data, they have 
provided an opportunity for adversaries to take advantage 
from this sensitive knowledge. So this work addresses the 
problem of sequential pattern hiding, and proposes an efficient 
and applicable algorithm which benefits from a multi-objective 
scheme to fulfill the requirements of the problem as well as 
maintaining database fidelity as much as possible. 
Keywords-privacy preserving data mining; sequential pattern 
hiding; knowledge hiding 
I.  INTRODUCTION 
Recent advancements in the data mining field have made 
opportunities to get access to the knowledge concealed in 
vast amount of data. Nonetheless, the divulged knowledge 
could also be considered adversely, inasmuch as every 
unauthorized person could elicit and use it to take advantage 
over database owners. To give a clear-cut example, consider 
a market which gathers its costumers' transactions, and by 
analyzing them extracts their purchase patterns, so by 
utilizing it could design promotions for other products. But it 
will lose its business situation over their competitors, if they 
get access to this sensitive knowledge, owing to the fact that 
this provides an opportunity for others to steal this market's 
business advantage. Clearly, an organization could neither 
keep its data hidden nor publish it thoroughly; a compromise 
should be made. Withholding others to take advantage of our 
data, and preserving our knowledge privacy are the main 
objectives of the knowledge hiding process and received 
conspicuous attention in recent years. 
There are varieties of methods to achieve this, and 
majority of them try to alter the database, which to be 
published. The altered database is also called the sanitized 
database. But majority of sanitization methods and 
algorithms have dealt with classic and simple forms of 
databases and knowledge so far, namely frequent itemsets 
and association rules. In [1, 2] disjoint sensitive association 
rules were hidden one at a time by reducing their support or 
confidence. The works in [3, 4, 5] introduced unknown 
values, and again aimed to reduce association rules' support 
or confidence. Authors of [6] defined a sanitization matrix, 
and used it to hide frequent patterns. The work by Oliveira et 
al. [7] concerned with sharing the association rules and 
hiding the sensitive ones rather than the data. An algorithm 
was introduced by Aggarwal et al. [8] for the problem of 
protecting sensitive entries in a database. Authors of [9, 10] 
presented a border-based approach to hide frequent itemsets. 
A new form of practical knowledge, co-ocurring itemsets, 
and approaches for hiding it were proposed by Abul and et al. 
[11]. 
But a relatively new and more structured form of data has 
been presented recently which is sequence mining [12]. 
Incontrovertibly, knowledge preserving should be applied to 
this category of data, too, due to its more capability to cope 
with real world problems. Little research has been done in 
this field. Abul et al. [13] addressed this problem in their 
work. So the aim of this paper is to propose a novel 
algorithm to surmount the problem of sequential pattern 
hiding in sequence databases in more expeditious ways than 
[13].  
This paper is organized as follows. In section II we 
present some background information and the notation used 
in the rest of the paper. In section III we introduce our 
approach to attack the sequential pattern hiding problem, an 
algorithm is presented, and enforcement of constraints is 
included, too. Section IV contains wide range of experiments 
and comparisons. Finally, we conclude the discussion in 
section V. 
Volume 1
C 978-1-4244-5586-7/10/$26.00      2010 IEEE
  154
II. PROBLEM STATEMENT 
In this section, first some basic definitions of sequence 
data mining, which are based on [14], are stated, and then a 
depth discussion about the problem of sequential pattern 
hiding will be followed. 
A sequence is an ordered list S = s1s2...sl, where each si(1 
 i  l) is an itemset, and is called an element which is 
denoted as (x1x2...xm) such that each xk(1  k  m)? , and  
is a finite set of distinct items. A sequence a = a1a2...an is 
called a subsequence of another sequence b = b1b2...bm and b 
a super-sequence of a, if there exists integers 1  j1 < j2 <...< 
jn  m such that a1 ? bj1, a2 ? bj2, …, an ? bjn. In addition, a 
sequence database SDB contains a set of sequences. The 
support of a sequence a in a SDB is the number of sequences 
in SDB that are super-sequences of a: supSDB() = |{S ? 
SDB subsequence of S}|. A sequence a is called a 
sequential pattern in SDB if supSDB()  min-sup. 
Given a sequence S=s1…sn and a subsequence S'=s'1…s'm, 
a set of positions {i1, i2, …, im} is called an occurrence of S' in 
S if 1  i1 <...< im  n and s'k = sik  for each 1  k  m. 
Consider S = bab(cd)(abd)bb(cbd) and S' = (cd)bb. 
Occurrences of S' in S are {4, 5, 6}, {4, 5, 7}, {4, 5, 8}, {4, 6, 
7}, {4, 6, 8}, and {4, 7, 8}, which occurrences' indices 
correspond to element numbers. 
Given a sequence database and a minimum support 
threshold, the sequential pattern mining problem is to find 
the complete set of sequential patterns in the database. 
Definition (related occurrence set of an item in a 
sequence): given a sequence S, a sequential pattern SP, and 
an item x which is the ith item from SP, the related 
occurrence set of x from SP in S encircles item numbers in S 
which correspond to item x from SP and is denoted as 
rossps(x:i). 
For example, if S = bab(cd)(abd)bb(cbd), and SP = 
(cd)bb, the related occurrence set of 3th item from SP, i.e. b, 
in S is ros(cd)bbs(b:3) = {7, 9, 10}. 
Definition (Sensitive Patterns): Sensitive patterns are 
sequential patterns which are determined sensitive by field 
experts, and must be hidden. In addition, we refer to items in 
sensitive patterns as sensitive items. 
Problem definition: Given a sequence database SDB, a 
sensitive pattern set SPS, and a hiding threshold , the goal is 
to minimally alter the SDB to hide all of sensitive patterns in 
it by reducing their support to . 
There are four important issues in the definition. First, 
the database's sequences should be altered. This will be done 
by replacing some of their element's items by unknown value 
"?". We refer to the number of item changes as distortions. 
Second, the term "minimally" imposes that distortions should 
be as few as possible, due to the fact that distortions decline 
data's quality. Then, the support of sensitive patterns must 
reduce to exactly , because excessive support declining 
diminishes database's quality, but in [13], the authors require 
that sensitive patterns' support must not be more than , so 
they permit excessive support declining in their algorithm. 
Next, in our work we cope with complex sequential patterns 
rather than the simple form. Simple sequences, which are the 
subject of [13], contain a single item as their elements 
instead of itemsets. 
III. THE PROPOSED APPROACH 
The proposed approach and its comparison with [13], the 
presentation of the hiding algorithm, and handling 
constraints are discussed in this section. 
A. Overview of the Proposed Hiding Approach 
The definition of the problem is very generic that needs 
further clarification in every aspect of it.  Firstly, we need to 
explain how a sequential pattern vanishes from a sequence: 
to do this all the occurrences of the sequential pattern must 
be cleared from the sequence, such that the sequential pattern 
no longer is supported by the sequence. Again, consider the 
sequence S = bab(cd)(abd)bb(cbd) and the sequential pattern 
SP = (cd)bb. To hide SP it is adequate to select one of its 
items, for instance, item c from first element of SP, i.e. the 
item number 1, and to replace all items in S with "?" which 
are included in ros(cd)bbs(c:1) = {4}.  So the sanitized 
sequence with one distortion S = bab(?d)(abd)bb(cbd). Note 
that the other item c in the S, the 11th item, remains intact. 
Other alterations are plausible. For example, the sanitized 
sequence bab(cd)(abd)??(c?d) is acquired by choosing item 
number 3 from SP and by replacing "?" with its related 
occurrences. Distinctly, this would not be a good solution 
owing to its imposed distortions. Now, consider a case which 
a sequence S = bab(cd)(abd)bb(cbd) comprises more than 
one sensitive pattern: ac(ad) and (cd)bb. The sanitized S = 
bab(?d)(abd)bb(cbd) is gained by solely one distortion, 
because rosac(ad)s(c:2) = ros(cd)bbs(c:1) = {4}. As a result, 
the sequence should be sanitized with fewer distortions as 
possible. It is worth mentioning that optimal sanitization, 
which is hiding all occurrences of sensitive patterns in a 
sequence is NP-Hard [13]. 
To clarify the sanitization process take into account our 
sample database in table I, the hiding threshold  = 1,  and a 
sensitive pattern set SPS = {ac(ad), (cd)bb, ebe}, which 
sup(ac(ad)) = 2, sup((cd)bb) = 3, and sup(ebe) = 2. So the 
patterns in SPS should be hidden by reducing their supports 
to . 
We introduce a multi-objective sequence selection 
framework to surmount the sensitive patterns hiding problem 
which first analyzes each sequence of the database and finds 
the best candidate solution to sanitize it, and then by 
comparing all best candidates in the database, it selects the 
winner sequence, i.e. the best overall candidate, and applies 
it to the corresponding sequence, so the support of some 
sensitive patterns will reduce by one unit. This process will 
iterate until all sensitive patterns' supports ascend to the exact 
value of . 
TABLE I.  SAMPLE DATABASE 
Sequence ID (s-id) Sequence 
1 bab(cd)(abd)bb(bcd)
2 (cd)ac(ad)cbeb(ad)e 
3 (cd)b(cd)bebe 
 
Volume 1
  155
The candidate solution selection process should consider 
the following factors: 
1. Number of sensitive patterns (SP) which their 
supports will be reduced one unit by the solution. 
2. Number of distortions (D) of the candidate solution. 
3. Number of non-sensitive patterns which their 
supports will reduce by one unit by the solution 
(NSP). 
Factor SP holds positive effect and should be maximized, 
while the effects of D and NSP is negative and need to be 
minimized. Thus, the problem of hiding all sequences s?SPS 
in sequential data base SDB is defined as to find s' as a 
subsequence of s to be hidden and changing SDB into SDB' 
so that: 
 
 Max SP(s'), Min D(s'), Min NSP(s') (1) 
 s.t. s' subsequence of s, for all s ? SPS                         
 supSDB'(s) =  , for all s ? SPS 
 
To solve the above multi-objective optimization problem, 
a weighted summation of the above objectives is introduced: 
 
F(SP(s'), D(s'), NSP(s')) =  × SP(s') ? ( × D(s') +  × NSP(s')) (2) 
 , , and  ? [0,1] 
  
The sequence analysis process, which results in the best 
solution, is conducted by constructing a candidate tree. The 
candidate tree is composed of all possible solutions to 
sanitize a sequence in such a way that each of its nodes is a 
solution, so each of them encircles the following information: 
1) the sensitive items involved, and 2) the associated 
objective functions or a 3-tuple, i.e. (SP, D, NSP). Fig. 1 
depicts the candidate tree for the sequence with s-id = 3 in 
table I. This sequence comprises two sensitive patterns: 
(cd)bb and ebe. For the sake of simplicity the effect of NSP 
is ignored:  = 0. The number of items in a sensitive pattern 
is included in the repeated items to help distinguish them 
from each other. 
An important point about the candidate tree is that first it 
examines solutions which are composed of a single sensitive 
item. These solutions could be seen in the first level of the 
candidate tree in Fig. 1, and then pairs of solutions with a 
sensitive item are amalgamated, and the result will be the 
solutions with couple of sensitive items, but as it is clear in 
the candidate tree of Fig. 1, none of the sensitive items from 
a same sensitive pattern are coalesced; there is no need to 
hide a sensitive patterns by hiding more than one of its items 
in the sequence. As a result, to avoid this, some 
amalgamation criteria are considered: solutions which 
construct the ith level of the candidate tree must incorporate 
the combination of i items from i distinct sensitive patterns, 
so: 
• To yield solutions with two sensitive items all the 
solutions which contain one item and are compatible 
with the above criteria will participate. 
• Solutions with three or more sensitive items are 
produced in a similar fashion. 
So if a candidate tree is merely constructed on a single 
sensitive pattern, no combination will be necessary. 
Therefore, by using this bunch of rules when constructing a 
candidate tree a huge number of unnecessary and useless 
solutions will be pruned beforehand. 
So far the sequence with s-id = 3 is analyzed by 
constructing its candidate tree. Now, based on the objective 
function F, the best solution will be determined. In 
aggregation, there are four combinations of (SP, D) in the 
candidate tree in Fig. 1: (1, 2), (2, 3), (1, 1), and (2, 2), and 
assume  = 0.5, 	 = 1, and F(1,2) = ?1.5, F(2,3) = ?2, F(1,1) 
= ?0.5 and F(2,2) = ?1, so the third solution will be the 
winner. To exhibit the significance of the weighted F to 
decide the winner, consider another example with  = 1, 	 = 
0.5. The winner solution in this case is the fourth solution 
with F(2,2) = 1. The winner solutions in both cases are 
circumscribed in Fig. 1. Moreover, it worth mentioning that 
if two or more solutions with the same value for the F 
function have the highest value among other solutions, the 
winner is selected based on a preconceived preference. For 
instance, one may prefer fewer distortions. 
In Fig. 1 distortions number for solutions is calculated 
based on the related occurrence sets. For instance, for the 
node b:4,b(2,2), which is equivalent to one of the winners, 
roscd(bb)s-id:3(b:4) ? rosebes-id:3(b:2) = {6,8} ? {8} = {6,8}, 
which means two distortions are required. 
Candidate trees of other two sequences in the sample 
database in table I will be constructed, and the overall winner 
will be pointed out and applied to the corresponding 
sequence. Assuming  = 0.5, 	 = 1, table II shows overall 
winners and their results on the database and supports of 
sensitive patterns. As a result, by only two distortions the 
sample database is sanitized, and, furthermore, this approach 
does not obtrude any extra distortions by reducing the 
support of some sensitive patterns below the . 
In the proposed approach in [13], the authors first sort the 
database's sequences in ascending order according to the 
number of sensitive pattern occurrences in them, second 
select the first |SDB| ?  sequences, where |SDB| is the size 
of the database, then sanitize them by hiding all the 
occurrences of sensitive patterns in them. So this method 
necessitates that when a sequence is selected for sanitization, 
all the sensitive patterns must be deleted from it, while it is 
not necessary; we should consider the entire database for 
sanitization not just a single sequence at a time; in addition, 
by sanitizing all the sensitive patterns from the selected 
sequence, we might lose the opportunity to sanitize the 
database with fewer distortions. In the table II in the second 
iteration the sequence with s-id = 2 is selected as the overall 
winner, but after altering it, it still contains the sensitive 
pattern ac(ad). Moreover, by selecting top |SDB| ?  sorted 
sequences, some sensitive patterns' supports might descend 
below the  which will cause unnecessary distortions. For 
instance, the sequences in table I contain 7, 5, and 4 
occurrences of sensitive patterns respectively, so according 
to the method of [13] the sequences with s-id = 3 and s-id = 
2 will be sanitized in order with 2 and 3 distortions 
respectively. So with 5 distortions the database is sanitized. 
Furthermore, after the sanitization sup(ebe) = 0, but our 
approach imposes neither excessive distortions, nor 
excessive support declination. 
Volume 1
  156
                                               cd(bb)                                                                                                              ebe 
c(1,2)                      d(1,2)                             b:3(1,2)                         b:4(2,2)                      e:1(1,1)                   b(1,1)                  e:3(1,1) 
 
 
 
 c,e:1(2,3)     c,b(2,3)     c,e:3(2,3)     d,e:1(2,3)     d,b(2,3)     d,e:3(2,3)     b:3,e:1(2,3)     b:3,b(2,3)     b:3,e:3(2,3)     b:4,e:1(2,3)     b:4,b(2,2)     b:4,e:3(2,3) 
 
Figure 1.  Candidate tree for the sequence with s-id = 3 in table I 
TABLE II.  SANITIZATION PROCESS FOR SAMPLE DATABASE IN TABLE I 
Iteration Data base Winner (s-id)  Replace location Supports ac(ad) (cd)bb ebe 
1 
bab(?d)(abd)bb(cbd)
(cd)ac(ad)cbeb(ad)e
(cd)b(cd)bebe 
1 4 1 2 2 
2 
bab(?d)(abd)bb(cbd)
(cd)ac(ad)cbe?(ad)e
(cd)b(cd)bebe 
2 10 1 1 1 
B. The Proposed Algorithm 
The novel hiding algorithm MOSS (Multi-objective 
Sequence Selection) is presented in Fig. 2, and summarizes 
our hiding framework. In this algorithm DBSeqsToCheck, 
which at first holds the s-id of all sequences, is used to 
determine which SDB sequences should be checked in the 
next iteration. The algorithm iterates until all sensitive 
patterns become hidden. In the first step it finds the best 
candidate solution for each sequence, and then finds the 
best solution for the entire SDB. This solution is applied to 
the corresponding sequence, and as a result of that 
supports of sensitive patterns in that sequence will be 
reduced by one unit. In this point those sensitive patterns 
which are successfully hidden are deleted from the SPS. 
One of the features of our algorithm is that after the 
first iteration, which in it all sequences in SDB are checked, 
it solely rechecks the updated sequence as well as those 
sequences which contain the hidden sensitive patterns, 
given the fact that their candidate tree will not include the 
hidden sensitive patterns anymore. Other sequences' 
candidate trees will remain intact. Therefore, a small 
number of sequences are checked in each iteration. 
 
Algorithm: MOSS 
INPUTS: SDB, SPS, , , 	,  - OUTPUT: sanitized SDB (SDB') 
DBSeqsToCheck 
 all s-ids 
While |SPS| > 0
1. For each s-id in DBSeqsToCheck 
1.1. Generate solutions which consider one 
sensitive item for deletion 
1.2. Combine solutions to generate solution tree 
1.3. Compute rank of each solution 
1.4. bestSolutions 
 highest ranked solution in 
the solution tree 
2. Find best overall solution 
3. Apply best overall solution and update SDB 
4. Decrease support of affected sensitive patterns 
5. For each sp in SPS 
5.1. If sup(sp) =  then remove sp from SPS 
6. Empty DBSeqsToCheck 
7. DBSeqsToCheck 
 updated sequence's s-id 
8. DBSeqsToCheck 
 s-id of sequences which 
contain removed sensitive patterns 
9. For each s-id in DBSeqsToCheck 
                   9.1.    Delete the corresponding bestSolution 
Figure 2.  MOSS algorithm 
C. Handling Constraints 
The two types of constraints namely max/min gap and 
max/min distance could conveniently be enforced to the 
hiding algorithm; no change is required in the algorithm in 
Fig. 2, and a solitary part that needs reconsideration is the 
definition of the related occurrence set. If a sequence S 
contains a subsequence SP, then a max/min gap constraint 
demands that the number of elements in S which are 
between every two elements of SP be less than (max + 1) 
and more than (min – 1). In this case the related occurrence 
set is denoted as gaprosSPS(x:i, min, max). Moreover, a 
max/min distance constraint obliges that the number of 
elements in S which are between the first and the last 
elements of SP be in the interval [min, max]. In this case 
the related occurrence set is denoted as disrosSPS(x:i, min, 
max). The following corollaries are obvious about the 
related occurrence sets: 
 
 gaprosSPS(x:i, min, max) ? rosSPS(x:i) (3)              
  disrosSPS(x:i, min, max) ? rosSPS(x:i) (4)               
 
So to generate the newly introduced related occurrence 
sets, the rosSPS(x:i) is computed at first, and then those 
item numbers which cannot satisfy the constraints will be 
excluded from it. For the sequence with s-id = 1 in table I, 
gaprosac(ad)s-id=1(a:3, 1, 2) = {10} ? rosac(ad)s-id=1(a:3) = 
{5, 10}. In another example, disrosac(ad)s-id=1(a:3, 0, 1) = 
. In addition, these constraints could be forced into the 
hiding approach simultaneously. 
IV. EXPERIMENTAL RESULTS 
We evaluate our algorithm with three datasets. The 
first dataset is a randomly generated dataset over the 
alphabet {a, b, c, d} which contains 10000 complex 
sequences (sequences which are compatible with the 
definition of a sequence in section 2). The second dataset 
is the Molecular Biology dataset [15] with 106 DNA 
Volume 1
  157
sequences of length 57. The MSNBC.com Anonymous 
Web dataset [16] is our third dataset which incorporates 
989818 sequences over integers from 1 to 17 as its items. 
Each sequence is page views of a user during a 24-hour 
period, and the first 5000 sequences have been considered 
in the experiments. We denote these datasets as Random, 
DNA, and WEB respectively. 
We compared our algorithm with the other sequence 
hiding approach [13] which we refer to it as OSH. Number 
of distortions is one of our measurements, and the other 
one is infidelity measure which encompasses those non-
sensitive patterns which their support fall below the 
support threshold after sanitization. 
Randomly selected sensitive patterns and other 
information regarding the datasets are shown in table III. 
Throughout the tests we use a certain notation to refer to 
the algorithm and other information which is <algorithm-
name, (,,), constraint>. The second and third elements 
are optional. Because the algorithm in [13] cannot deal 
with complex sequences, we adopt it to accept them. 
In the figures the x-axis is always the hiding threshold, 
i.e. , and the y-axis is either the distortion or infidelity. 
Fig. 3.a, 3.b, and 3.c depict the number of distortions in 
Random, DNA, and WEB datasets respectively. The 
gradual entry in <MOSS-(1,gradual,0)> in Fig. 3.a 
indicates that  gradually increases from 0.1 to 1 as  
ascends. To further discuss the impact of objective 
function the MOSS results are presented with different 
settings of the 3-tuple (,,). As it is clear in Fig. 3.a, 3.b, 
and 3.c the MOSS with/without constraint surpasses the 
OSH with/without constraint. 
Fig. 4.a, 4.b, and 4.c show the infidelity measure in 
datasets, and prove the better results of MOSS. 
Furthermore, the effect of , which aims to preserve non-
sensitive patterns according to the objective function, is 
eminent in the figures, but we have to say that this often 
has a negative effect on distortions, which is clear in Fig. 
3.a when comparing <MOSS, (1,1,1)> with <OSH>, but, 
on the other hand, the infidelity measure decreases 
dramatically when comparing the results with the effect of 
 with those that ignore it. 
TABLE III.  DATASETS INFORMATION 
Dataset Support threshold Patterns Sensitive patterns
Random 1000 837 b(ab)b, cbb, cb(ab)a
DNA 106 35628 caatttgcaa, ggcggac
WEB 100 109 1 6 6, 2 2 1 
V. CONCLUSION 
In this paper we addressed the problem of hiding 
sequential patterns. The main contributions of this work 
over the other algorithm in the literature [13] could be 
summarized in dealing with complex form of sequences 
rather than simple sequences, and presenting a more 
efficient algorithm which hides sensitive patterns from a 
sequence database with fewer distortions, so data quality is 
preserved. Furthermore, we presented a highly flexible 
weighted objective function to find best solution among all 
candidate solutions to sanitize sequences. Moreover, 
handling constraints was another topic of discusstion. 
Experimental evaluations carried out on three datasets with 
distinct characteristics to prove the promised functions of 
both the algorithm and the objective function. The results 
indicated that the proposed algorithm surpasses the 
existing one significantly. 
 
Random dataset 3.a
0
2000
4000
6000
8000
10000
12000
0 100 200 300 400 500 600 700 800 900
hiding threshold
di
sto
rti
on
MOSS, (1,gradual,0) MOSS, (1,1,1)
MOSS, (1,1,0), gap2,5 MOSS, (1,1,0), dis6,9
OSH OSH, gap2,5
   
DNA dataset 3.b
0
100
200
300
400
500
600
700
0 10 20 30 40 50 60 70 80 90 100
hiding threshold
di
sto
rti
on
MOSS, (1,gradual,0) MOSS, (1,1,0)
MOSS, (1,0.1,0) MOSS, (1,1,0), gap4,9
MOSS, (1,1,0), dis15,22 OSH
OSH, gap4,9
   
WEB dataset 3.c
0
100
200
300
400
500
600
700
0 10 20 30 40 50 60 70 80 90
hiding threshold
di
st
or
tio
n
MOSS, (1,1,0) MOSS, (1,1,1) OSH
 
Figure 3.  Distortions in Random, DNA, and WEB datasets 
 
Volume 1
  158
Random dataset 4.a
150
170
190
210
230
250
270
290
310
330
350
0 100 200 300 400 500 600 700 800 900
hiding threshold
in
fid
el
ity
MOSS, (1,gradual,0)
MOSS, (1,1,1)
OSH
 
D N A  dataset  4.b
0
5000
10000
15000
20000
25000
30000
35000
40000
0 10 20 30 40 50 60 70 80 90 100
hiding threshold
in
fid
el
ity
M OSS, (1,gradual,0)
M OSS, (1,1,0)
M OSS, (1,0.1,0)
OSH
WEB dataset 4.c
0
2
4
6
8
10
12
0 10 20 30 40 50 60 70 80 90
hiding threshold
in
fid
el
ity
MOSS, (1,1,0)
MOSS, (1,1,1)
OSH
 
Figure 4.  Infidelities in Random, DNA, and WEB datasets 
 
 
 
REFERENCES 
[1] E. Dasseni, V. S. Verykios, A. K. Elmagarmid, and E. Bertino, 
“Hiding Association Rules by Using Confidence and Support,” 
Proc. 4th International Workshop on Information Hiding, Springer-
Verlag, 2001, pp. 369-383. 
[2] V. S. Verykios, A. K. Elmagarmid, E. Bertino, Y. Saygin, and E. 
Dasseni, “Association rule hiding,” IEEE Transactions on 
Knowledge and Data Engineering, vol. 16, issue 4, 2004, pp. 434-
447, doi: 10.1109/TKDE.2004.1269668. 
[3] Y. Saygin, V. S. Verykios, and A. K. Elmagarmid, “Privacy 
Preserving Association Rule Mining,” Proc. 12th International 
Workshop on Research Issues in Data Engineering: Engineering E-
Commerce/E-Business Systems (RIDE'02), IEEE Computer 
Society, 2002, p. 151. 
[4] Y. Saygin, V. S. Verykios, and C. Clifton, “Using Unknowns to 
Prevent Discovery of Association Rules,” ACM SIGMOD Record, 
vol. 30, issue 4, 2001, pp. 45-54. 
[5] E. D. Pontikakis, Y. Theodoridis, A. A. Tsitsonis, L.  Chang, and V. 
S. Verykios, “A Quantitative and Qualitative Analysis of Blocking 
in Association Rule Hiding,” Proc. ACM workshop on Privacy in 
the electronic society (WPES'04), ACM, 2004, pp. 29-30. 
[6] G. Lee, C. Chang, and A. L. P. Chen, “Hiding Sensitive Patterns in 
Association Rule Mining,” Proc. 28th Annual International 
Computer Software and Applications Conference (COMPSAC'04), 
IEEE Computer Society, 2004, pp. 424-429. 
[7] S. R. M. Oliveira, O. R. Zaiane, and Y. Saygin, “Secure 
Association Rule Sharing,” Proc. 8th Pacific-Asia Conference, 
Advances in Knowledge Discovery and Data Mining (PAKDD'04), 
Springer, 2004, pp. 74-85. 
[8] C. C. Aggarwal, J. Pei, and B. Zhang, “On Privacy Preservation 
Against Adversarial Data Mining,” Proc. 12th ACM SIGKDD 
international conference on Knowledge discovery and data mining,  
ACM, 2006, pp. 510-516. 
[9] X. Sun and P. S. Yu, “A Border-based Approach for Hiding 
Sensitive Frequent Itemsets,” Proc. 5th IEEE International 
Conference on Data Mining (ICDM'05), IEEE Computer Society, 
2005, pp. 426-433, doi: 10.1109/ICDM.2005.2. 
[10] G. V. Moustakides and V. S. Verykios, “A Max Min Approach for 
Hiding Frequent Itemsets,” Data & Knowledge Engineering, 
Elsevier Science Publishers B. V.,  vol. 65, issue 1, 2008, pp. 75-89, 
doi: 10.1016/j.datak.2007.06.012. 
[11] O. Abul. “Hiding Co-Occurring Frequent Itemsets,” Proc. 2nd 
International Workshop on Privacy and Anonymity in the 
Information Society (PAIS’09), in conjunction with 
ICDT/EDBT'09, 2009. 
[12] R. Agrawal and R. Srikant, “Mining Sequential Patterns,” Proc. 
11th International Conference on Data Engineering (ICDE95),  
IEEE Computer Society, 1995, pp. 3-14. 
[13] O. Abul, M. Atzori, F. Bonchi, and F. Giannotti, “Hiding 
Sequences,” Proc. IEEE 23rd International Conference on Data 
Engineering Workshop (ICDEW 2007), IEEE Computer Society, 
2007, pp. 147-156, doi: 10.1109/ICDEW.2007.4400985. 
[14] G. Dong and J. Pei, Sequence Data Mining, 1st ed., Springer, 2007. 
[15] C. Harley, R. Reynolds, UCI Machine Learning Repository, 
[http://archive.ics.uci.edu/ml/datasets/Molecular+Biology+(Promot
er+Gene+Sequences)]. 
[16] David Heckerman, UCI Machine Learning Repository, 
[http://archive.ics.uci.edu/ml/datasets/MSNBC.com+Anonymous+
Web+Data]. 
 
Volume 1
