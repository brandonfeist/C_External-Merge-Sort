Considering RFM-Values of Frequent Patterns in 
Transactional Databases 
Ya-Han Hu 
Department of Information Management 
National Chung Cheng University 
Chia-Yi, Taiwan, R.O.C. 
yahan.hu@mis.ccu.edu.tw 
Fan Wu 
Department of Information Management 
National Chung Cheng University 
Chia-Yi, Taiwan, R.O.C. 
kfwu@mis.ccu.edu.tw 
Tzu-Wei Yeh 
Department of Information Management 
National Chung Cheng University 
Chia-Yi, Taiwan, R.O.C. 
jimwayne@mis.ccu.edu.tw 
Abstract—Market basket analysis is an important data mining
application for finding correlations between purchasing items in 
transactional databases. Previous works show that considering 
constraints which users may concerned with into the mining 
process can effectively reduce the number of patterns and get 
more promising information. In this study, we extend the RFM 
analysis into the mining process to measure the importance of 
frequent patterns. In RFM analysis, a customer to be recognized 
as valuable if his/her purchasing records are recent, frequent, 
and having high amount of money. Follow the same concept of 
RFM analysis, we first define the RFM-patterns. The RFM-
patterns we discovered are not only frequently occurred but also 
recently bought and having a higher percentage of revenue. After 
that, we propose a tree structure, named RFMP-tree, to compress 
and store entire transactional database, and a pattern growth-
based algorithm, called RFMP-growth, is developed to discover 
all RFM-patterns from RFMP-tree. In experimental evaluation, 
the results show that the algorithm can both significantly reduce 
the number of discovered patterns and efficiently find the RFM-
patterns. 
Keywords: market basket analysis, frequent pattern mining, 
RFM analysis, constraint-based mining. 
I. INTRODUCTION
Association rule mining is one of the most prominent 
research topics in data mining. It can be used in discovering 
relationships among items or events in various application 
domains. By given a user-specified threshold, also known as 
minimum support, the mining of association rules can discover 
the complete set of frequent patterns. That is, once the 
minimum support is given, the complete set of frequent 
patterns is determined. In order to retrieve more correlations 
among items, users may specify a relatively lower minimum 
support. Such a lower support often generates a huge amount 
of frequent patterns; but most of the patterns are already known 
or not interested to users. It is a tedious task for users to filter 
out these valueless patterns. 
Previous works [1-2] showed that pushing constraints 
which users concerned with into the mining algorithm can 
effectively reduce the number of patterns and get more 
promising information. Furthermore, instead of filtering 
patterns after the completion of the mining process, pushing 
additional constraints directly into the mining procedure can 
allow more efficient algorithm. For example, users may want 
such patterns that occur only in a specific period of time, 
contained specific itemsets, or follow some regular expressions 
[2]. Such constraints may meet the users’ need and provide an 
effective and efficient way to gain more meaningful 
information. 
In this study, we consider constraints developed from the 
RFM analysis to examine the interestingness of frequent 
patterns into the mining algorithm. RFM (Recency, Frequency 
and Monetary) analysis [3] is a well-known and powerful tool 
in database marketing and is widely used in measuring the 
values of customers according to their prior purchasing history. 
Valuable customers can be defined as those whose purchasing
behaviors occur frequently and recently and whose purchasing 
records show high consumption ability, i.e. high total 
transaction amount. The same concepts can be used to evaluate 
the value of frequent patterns. That is, a frequent pattern is 
treated as valuable if it occurs frequently in both the whole 
database and the recent period, and the pattern can provide 
higher revenue for business. According to the description 
above, we develop a scoring-based method from RFM to 
evaluate the interestingness of patterns. Recency score denotes 
the number of a pattern’s occurrences in recent period. The 
more recent occurrences of a pattern does, the higher recency 
score it will get. Frequency score denotes the support count of 
the pattern. Monetary score denotes the amount of money that 
all customers spent on this pattern. A pattern with high recency 
and frequency scores implies that the pattern is important 
recently and over the long periods of time, while a pattern with 
high monetary score is important since it contributes higher
revenue to business. 
Follow the concepts of scoring method described above, we 
call a pattern is a RFM-pattern if its recency score, frequency 
score, and monetary score satisfies user-specified minimum 
recency, frequency, and monetary thresholds in this paper,
respectively. Then, we design a compact tree structure, called 
RFMP-tree (RFM-pattern tree), which compresses and stores 
the necessary information of the entire transaction database 
within it. Based on the tree, we developed a pattern growth 
algorithm, called RFMP-growth, to discover complete set of 
RFM-patterns. 
The rest of our study is organized as follows: Section 2 
shows the literatures relevant to this paper. Section 3 gives the 
definitions and notations used in the study. Section 4 describes 
the algorithm and gives some examples to illustrate it. The 
422
experiment result is shown in section 5, and Section 6 
concludes the study. 
II. RELATED WORK
There are some studies dealing with the concept of recency 
or monetary in frequent pattern mining. For example, Wu et al. 
[4] discussed the recency problem about the change of data 
distribution between the past data and the new data. Emerging 
patterns, introduced by Dong and Li [5], discover the 
significant change in the same dataset but with different time 
periods. For another example, the utility mining [6-7] is a type 
of data mining considering the monetary that measure the 
importance of frequent pattern according to their monetary 
value (i.e. profit).  
Although several existing researches [8-9] use concepts 
similar to RFM in measuring the importance of frequent 
patterns, they still fail to fully reflect the requirement of RFM 
in the mining process. For example, RFM-Apriori [9] defined 
recency constraint that the occurring time of the last transaction 
of a pattern should satisfy the recency threshold. Similarly to 
recency, monetary is defined as that the total amount of money 
spent by all customers in a pattern should fall into the range 
between the maximum and minimum monetary thresholds. The 
paper in [9] proposed an algorithm for mining patterns 
satisfying RFM constraints; they used a fixed time gap that 
every occurrence of patterns within the given recent time 
period will have the same influence regardless of the occurring 
time. However, their approach cannot reflect the different 
length of stripes of recency in measuring the importance of 
transactions. To the best of our knowledge, there exist no 
comprehensive studies concerning all the three concepts of 
RFM analysis on frequent pattern mining simultaneously. In
this study, the proposed scoring-based method not only gives a
more reasonable approach, but also performs the complete 
concept of RFM on measuring the importance of patterns. 
III. PROBLEM DEFINITION
In traditional association rule mining, a customer 
transaction only contains a set of items. With the information, 
frequent patterns can be got. For a set I of items in a database, 
to measure the scores of RFM of itemsets, the database should 
contain the more information of a transaction X, like <tx, 
( 1a , 1aq ) ( 2a , 2aq )…( ma , maq )>, where tx stands for the 
transaction time when transaction X occurs, the m pairs, (ai,
iaq ), where 1? i?m and aiI, denotes that there are m
different items are purchased in the transaction and for item ai,
the purchased quantity is 
iaq .
Given an itemset Y (YI), Y is said to be contained in X if 
all items in Y also occur in X. 
Definition 1. Assume that an itemset Y is contained in 
transaction X. Y’s transaction recency score gained from X,
denoted by trscore(Y, X), is defined as: trscore(Y, X) = (1-
?)tcurrent-tx, where ? is a user-specified decay speed (?[0, 1]), 
tcurrent denotes the current timestamp. 
Decay speed is a parameter used to control the output of the 
transaction recency score. A larger decay speed represents that 
the recency of transaction X shrinks fast as tx decrease and will 
lead to a smaller trscore. On the contrary, a smaller decay 
speed will result in a higher trscore. Given two transactions Xi
and Xj containing itemset Y, the relationship trscore(Y, Xi)?
trscore(Y, Xj) will always hold when ti?tj (0<?<1).
Definition 2. Following Definition 1, the recency score of 
itemset Y, denoted by Rscore(Y), is defined as the sum of 
transaction recency score gained from all of the transactions 
containing it: 



DBX
sDB
s
XYtrscoreYRscore ),()( 	
Given a user-specified recency minimum support ?, an 
itemset Y is called a R-pattern if Rscore(Y)??. 
Example 1. Consider the transaction database DB shown in 
Fig. 1(a). Assume that the current time stamp tcurrent = 115 and 
let the decay speed ? = 0.01. Given an itemset {CE}, its 
transaction recency score in X5 (e.g. trscore({CE}, X5)) is 
equal to (1-0.1)115-45? 0.495. Moreover, {CE}’s recency 
score RscoreDB({CE})) ? trscore({CE}, X1)+trscore({CE}, 
X2)+…+ trscore({CE}, X1)=1.273. If ?=1 is set, we call an 
itemset {CE} is a R-pattern.
The concept of frequency is completely the same as the 
definition in traditional frequent pattern mining. We simply 
give the following definition. 
Definition 3. The frequency score of itemset Y in DB,
denoted by Fscore(y), is the number of transactions containing 
itemset Y. 
FscoreDB(Y)=|{Xs | Xs  DB 
 Y is contained in Xs }| (2) 
Given a user-specified minimum frequency support ?, an 
itemset Y is called a RF-pattern if (1) itemset Y is an R-pattern;
and (2) FscoreDB(Y??? |DB| ???. 
Example 2. Following Example 1, itemset {CE} is a R-
pattern. And the Fscore of itemset {CE} is equal to 2 since it is 
contained in transaction 5 and 7. If ??10% is set, then {CE} is 
called a RF-pattern because FscoreDB({CE}) ? 10×10%?1.
TID transaction
1 <0, (A, 1)(B, 2)(F, 1)>
2 <18, (A, 1)(B, 1)(F, 2)>
3 <22, (A, 2)(C, 1)>
4 <39, (A, 2)(B, 1)(E, 3)>
5 <45, (C, 1)(E, 7)>
6 <68, (A, 1)(E, 5)>
7 <90, (C, 2)(D, 1)(E, 10)>
8 <100, (A, 1)(C, 1)(F, 5)>
9 <109, (A, 2)(E, 8)(F, 1)(G, 1)>
10 <115, (A, 2)(D, 1)(E, 10)>
(a) Transactional database
Item Price
A 10
B 150
C 25
D 45
E 7
F 2
G 80
(b) Item unit price 
list
Figure 1. An example of transactional database and item unit price list 
423
Monetary stands for the value (amount of money) a specific 
itemset can provide from historical transactions. In this study, 
the definitions related to the monetary is similar to those in the 
mining of high utility patterns [6-7].
Definition 4. Let p(ai) denotes the unit price of item ai.
Assume that an itemset Y is contained in transaction X. An 
itemset Y’s transaction monetary score gained from X, denoted 
by tmscore(Y, X), is defined as: 

i
i
a
Ya
i qapXYtmscore  

)(),(
	
Definition 5. Following Definition 4, the monetary score of 
itemset Y in DB, denoted by MscoreDB(Y), is the sum of 
monetary score gained from transactions containing itemset y. 




DBX
sDB
s
XYtmscoreyMscore ),()( 	
Given a user-specified minimum monetary threshold ?, an 
itemset Y is called a RFM-pattern if (1) Y is a RF-pattern; and 
(2) MscoreDB(Y) ? ?.
Example 3. Following Example 2, itemset {CE} is a RF-
pattern. Consider the item unit price list shown in Fig. 1(b), for 
items C and E, their unit price is 25 and 7 respectively. Then 
{CE}’s transaction monetary score from X5 is tmscore({CE}, 
X5)?1×25?10×7?95. Moreover, the monetary score of {CE} 
gained from all transactions in DB is MscoreDB({CE})?
tmscore({CE}, X1)+ tmscore({CE}, X2)+…+ tmscore({CE}, 
X15) = 194. If ??100 is set, then we call {CE} is a RFM-
pattern since MscoreDB({CE}) ? 100 and it is also a RF-pattern.
In summary, given a transaction database and user-
specified minimum thresholds ?, ?, and ?, the goal of this study 
is to determine all RFM-patterns which the user interests in. 
Although the concept of RFM-pattern is simple, to 
simultaneously consider all three constraints into the mining 
process is not straightforward. The main problem is that 
monetary score doesn’t hold the downward closure property, 
i.e. a subset of a RFM-pattern may not be a RFM-pattern. 
Follow the parameter settings in Example 3, MscoreDB({F}) = 
18 doesn’t satisfy ? and {F} will never be a RFM-pattern. But 
its superset {BF} could be a RFM-pattern since 
MscoreDB({BF}) = 456 ? ?. In other words, the Mscore of an 
itemset’s superset is possible to be higher than that of an 
itemset itself. To effectively prune the search space, we adopt 
the concepts proposed in [6] to give the following definitions.
Definition 5. Following the Definition 4, the transaction 
amount for transaction X, denoted by ta(X), is the sum of all 
items’ monetary score in transaction Xs. 
i
i
a
Xa
i qapXta  

)()(
	
Definition 6. Based on definition 5, the total transaction 
amount of an itemset Y, denoted by Tta(Y), is defined as: 
)()(




ss XYDBX
sXtaYTta 	
Given a user-specified minimum monetary threshold ?, an 
itemset Y is called a RFT-pattern if (1) Y is a RF-pattern; and 
(2) TtaDB(Y) ? ?.
Example 4. Following Example 3, itemset {CE} is a RF-
pattern and is contained in transaction 5 and 7. Then its total 
transaction amount is Tta({CE})?ta(5)+ ta(7)=239. We call 
{CE} is a RFT-pattern since {CE} is a RF-pattern and 
Tta({CE}) ? ?=100.
IV. RFMP-TREE AND RFMP-GROWTH ALGORITHM
In this section, we introduce the RFMP-tree structure and 
the RFMP-growth algorithm, which are modified from the 
well-known FP-tree structure and FP-growth algorithm [10]. 
A. RFMP-tree construction 
A complete RFMP-tree contains a list, called RFM-header, 
and a RFMP-tree. A RFM-header is a list containing all the 1-
RFT-patterns (i.e. a RFT-pattern containing one item only), 
which are sorted according to their Fscore in descending order. 
Each entry in RFM-header consists five fields: item-name,
Rscore, Fscore, Tta, and head of node-link, where item-name
registers which item this entry presents, Rscore, Fscore, and 
Tta record the recency score, frequency score, and total 
transaction amount of this item, respectively, and head of node-
link points to the first node in RFMP-tree carrying the same 
item-name. 
Each node in RFMP-tree consists of five fields: item-name,
Rscore, Fscore, Tta, parent-link, child-link, and sibling-link,
where item-name registers which item this node represents, 
Rscore, Fscore, and Tta register the recency score, frequency 
score, and total transaction amount from all the transactions 
that have the corresponding patterns represented at this node, 
and parent-link, child-link, and sibling-link register the 
addresses of the parent node, child nodes, and the next node 
carrying the same item-name in the RFMP-tree, respectively. 
While constructing RFMP-tree, we need two database 
scans (briefly called DB scan in the following sections) to build 
the complete tree. We first collect information to compact the 
tree size, and then build the complete RFMP-tree, as shown in 
Fig. 2. In the first DB scan, we collect all items’ Rscore, Fscore,
and Tta to get all 1-RFT-patterns and store them in the RFM-
header. After that, we sort all 1-RFT-patterns in RFM-header 
according to their Fscore in descending order. In the second 
DB scan, we create the root node of the tree and label it as null.
For each transaction, we prune items not contained in RFM-
header, i.e. non-1-RFT-patterns, and sort the remaining items 
according to the order of items in RFM-header. The sorted 
items are then inserted one by one into the RFMP-tree. Each 
transaction in this case leads to be a branch in RFMP-tree. 
424
root
A
F
B
(0.315, 1, 312)
(0.315, 1, 312)
(0.315, 1, 312) ?
root
A
F
B
(0.692, 2, 476)
(0.692, 2, 476)
(0.692, 2, 476) ?
root
A
F
B
(1.085, 3, 521)
(0.692, 2, 476)
(0.692, 2, 476)
C
(0.393, 1, 45)
(a)                       (b)                                       (c)
root
A E
F C E C
B F D DB F
30021.778D
66731.158B
67942.494F
32942.525C
76864.304E
105984.976A
linkTtaFscoreRscoreitem
Figure 2. RFMP-tree construction algorithm
  
While inserting each transaction into RFMP-tree, two 
possible cases may occur. If there already exists a branch 
representing the transaction, we simply update all scores 
related to the transaction into the corresponding nodes. On the 
contrary, if there exists no corresponding branch, one may have 
to create all necessary node(s) and calculate initial scores for 
it/them. Once a new node is created, all the links related to this 
node have to be built up, including parent-link and node-links. 
The procedure insert_node, as shown in Fig. 3, is used to 
perform the functions describe above. 
Since the basic concept of the RFMP-tree construction is 
the same as the FP-tree, we only use examples to illustrate 
dissimilar parts as follows. Consider the transaction database
DB and item unit price list shown in Fig. 1, let ??1, ??10%,
??100, ??0.01, and the current time stamp tcurrent=115. After 
the first DB scan, the RFM-header retain all 1-RFT-patterns 
and their Rscore, Fscore, and Tta in Fig. 4. All items are 
already sorted in Fscore descending order. Below, we give the 
steps of inserting transaction 1, 2, and 3 into the RFMP-tree
while the second DB scan performs. We first sort transaction 1 
follow the order of items in RFM-header to form <0, (A, 1)(F, 
1)(B, 2)>. The three nodes with item-name equal to A, F, and B 
are created respectively, as shown in Fig. 5(a). Notice that 
while creating each new node, all of its scores and node-links 
have to be built up immediately. For nodes A, F, and B, 
transaction 1’s Rscore=0.315, Fscore=1, and Tta=10×1+150×2
+2×1=312 are stored in the nodes. For the next ordered 
transaction <18, (A, 1)(F, 2)(B, 1)>, it shares the same prefix 
(A)(F)(B) with the existing branch. So, we update node A’s, 
node F’s, and node B’s information based on transaction 2.
After calculation, its Rscore=0.377, Fscore=1, and 
Tta=10×1+150×1+2×2=164 is accumulated into the nodes, as 
shown in Fig. 5(b). For the third ordered transaction <22, (A, 
2)(C, 1)>, we first update node A’s information, Rscore=0.393,
Fscore=1, and Tta=10×2+25× 1=45, in the same way since it 
shares the same prefix (A). For the remaining 1 item, we insert 
a new node C as a child of node A, and transaction 3’s Rscore,
Procedure insert_node ([p|P], T, Xs.Rscore, Xs.Tta){
if T has a child node N such that N.item-name=p.item-name then
 update N’s Rscore, Fscore, and Tta.
else
 create a new node N with N.Fscore=1, N.Rscore = Xs.Rscore,and N.Tta=
Xs.Tta
 let N’s parent-link be linked to T
 let N’s node-link be linked to the nodes with the same item-name via the 
node-link structure
if P is nonempty then call insert_node(P, N, Xs.Rscore, Xs.Tta)
}
Figure 3. Procedure insert_node() 
Figure 4. The complete RFMP-tree 
Figure 5. An example of inserting transactions into RFMP-tree 
Fscore, and Tta is then stored in the nodes, as shown in Fig. 
5(c). Follow the same steps in the remaining transactions in DB,
at last, the complete RFMP-tree is shown in Fig. 4. 
B. RFMP-growth algorithm 
The RFMP- growth algorithm can be divided into two steps. 
In the first step we perform the pattern growth recursively and 
find all RFT-patterns from the RFMP-tree, as shown in Fig. 7.
The second step scans database once to compute the Mscore of 
all RFT-patterns and finally discover all RFM-patterns. 
In the pattern growth procedure, we search the RFM-header 
and traverse the RFMP-tree from the item’s node-link in RFM-
header. The item’s Rscore, Fscore, and Tta value can be 
collected by traversing nodes with the same item-name through 
the node-link structure. The item then will be outputted as a 
RFT-pattern if it satisfies the thresholds. After that, a 
conditional pattern base is generated for the following 
procedure. The conditional pattern base is a sub dataset which 
each pattern in it contains the item we just traversed from 
RFM-header. It can be generated by the RFMP-tree’s branches 
which are from the root node to the traversed nodes. After 
acquiring the complete conditional pattern base, the conditional 
Algorithm: RFMP-tree Construction
Input: a set of all transactions in DB, min_rscore ?, min_fscore ?,
min_mscore ?, decay speed ?
Output: RFMP-tree
Method: 
Initial the header table RFM-header;
foreach transaction Xs in DB do
 foreach item aiXs do
  if ai is not in RFM-header then add a new entry with item-name?ai in 
RFM-header;
  update ai’s Rscore, Frscore, and Tta value in RFM-header;
remove items not satisfying minimum thresholds ?, ?, or ? in RFM-header;
sort items in RFM-header by their Fscore in descending order;
Create the root node of a RFMP-tree T, label it as “null” ;
foreach transaction Xs in DB do
 remove items not exist in RFM-header;
 calculate and record Xs’s Rscore and Tta;
 sort the remaining items in the order of items in RFM-header;
 let the sorted items in Xs be [p|P], where p is the first element and P is the 
remaining list. 
 call insert_node( [p|P], T, Xs.Rscore, Xs.tta) ;
425
Input: RFMP-tree RT, ?, ?, ?
Output: a complete set of RFM-patterns
Method: Call RFMP-growth(RFMP-tree, null)
Procedure RFMP-growth(RT) {
 call tree-growth(RT, null) and get all RFT-patterns;
 scan DB once to get Mscores of RFT-patterns;
 output all RFM-patterns with their Mscores satisfying ?;
}
Procedure tree-growth(RT, ?) {
foreach item ai in RFM-header do
 let ai’s node-link is bi;
 if bi ? null then
  get bi’s Rscore, Fscore, and Tta by bi’s node-link structure;
  if bi.Rscore?? , bi.Fscore??, and bi.Tta?? then output bi;
  generate pattern ??ai ?, where ?.Rscore, ?.Fscore, and ?.Tta are 
equal to ai’s Rscore, Frscore, and Tta recorded in RFM-header, 
respectively;
  construct ?’s conditional pattern base and ?’s conditional RFMP-tree 
RT?;
  if RT??  then call tree-growth(RT?, ?);
}
Figure 6. The RFMP-growth algorithm 
RFMP-tree can be constructed using the same steps of 
constructing RFMP-tree. We can perform the mining procedure 
recursively with the conditional RFMP-tree and get all of the 
RFT-patterns. 
Here we give an example to show the tree growth 
procedure with considering only patterns with item D. Initially, 
the input itemset ? is null that we can traverse the RFMP-tree 
and generate all of the 1-patterns, including pattern {D}. By 
traversing the node-link structure, we can collect all the 
information of pattern {D}, and pattern {D} will be outputted 
since it satisfies the thresholds. The conditional pattern base of 
each 1-pattern is then constructed recursively. In this example, 
we only show item D’s conditional pattern base in Fig. 7.
While the complete pattern base of item D is constructed, we 
then construct D’s conditional RFMP-tree based on its 
conditional pattern base, as shown in Fig. 8(a). In the 
conditional tree construction step, item B and C will be 
removed from conditional RFMP-tree since they do not satisfy 
the thresholds, as shown in Fig. 8(b). After the tree growth 
complete, we can have all RFT-patterns which contain item D. 
The RFT-patterns outputted from D’s conditional RFMP-tree 
are {D}, {DE}, {AD}, and {ADE}. 
To find out all of the RFM-patterns from RFT-patterns, we 
use the hash-tree structure, which is a widely used tree 
structure in Apriori-based algorithms, to store the RFT-patterns. 
After inserting all RFT-patterns in the hash-tree, we scan the 
database and traverse the hash-tree for each transaction to 
check if the RFT-pattern is contained in the transaction. Each 
RFT-pattern’s Mscore value will be collected after the scan  
item conditional pattern base Conditional RFMP-tree
D
{(A: 0.456, 1, 236)(E: 0.456, 1, 
236)(B: 0.456, 1, 236)},
{(E: 0.778, 1, 165)(C: 0.778, 1, 
165)},
{(A: 1, 1, 135)(E: 1, 1, 135)}
{(E: 0.778, 1, 165)}|D,
{(E: 1, 1, 135 )(A: 1, 1, 
135)}|D
Figure 7. Item D’s conditional pattern base and conditional RFMP-tree 
               
(a)                                         (b)
Figure 8. Item D’s conditional RFMP-tree 
completes. For item D’s RFT-patterns as example, pattern {D} 
and {AD} will be pruned since MscoreD=90? ?, MscoreAD=65
??. Therefore, the RFM-patterns containing item D are {DE} 
and {ADE}. 
V. EXPERIMENTAL EVALUATION
In this section, we perform a simulation study to 
empirically compare the proposed algorithm with traditional 
association rule method (FP-growth). All the algorithms are 
implemented in Java language and tested on a DualCore 
Pentium E2180-2.0 GHz Windows XP system with 2 gigabyte 
of main memory. The three synthetic datasets are generated by 
IBM Quest Data Generator. Table I lists the parameters used in 
the data generation algorithm and Table II shows the parameter 
settings in our experiments. Since the synthetic datasets does 
not contain purchase quantity, item price, and transaction time, 
we generate all necessary information in the following way. 
The quantity of each item in the transaction is randomly 
generated from 1 to 10. Each item’s price is randomly 
generated in log-normal distribution, ranging from 1 to 50,000. 
The transaction time interval is drawn from a uniform 
distribution raging from 1 to 24, i.e. each transaction time will 
be later than that of prior transaction at most 24 time units. 
We also investigate a real-life dataset in our experiments. 
This real-life dataset contained all sales data of a supermarket 
in Taiwan from 2002/7/31 to 2002/11/28. Each row in this 
dataset records item ID, item quantity, and item price. After we 
perform all necessary data preprocessing tasks, the dataset 
contains 108,162 transactions and 9,943 items. 
As shown in table III, we have designed three threshold 
settings. The decay speed ? is set to be 0.001 in all tests. 
Besides, since tcurrent can significantly influence the Rscore of 
each pattern, we set tcurrent to be the same as the latest 
transaction time to enhance the influence of recency constraint. 
Moreover, since the FP-growth considers frequency constraint 
only, the recency and monetary thresholds will be discarded. 
TABLE I. PARAMETERS
|D| Number of transactions
|T| Average size of the transactions
|I| Average size of the maximal potentially large itemsets
N Number of items
Np Number of patterns
Lp Average length of maximal pattern
C Correlation between patterns
426
TABLE II. PARAMETER SETTINGS OF SYNTHETIC DATASETS
Name |D| |T| |I| N Np Lp C
SYN-1 100K 25 20 1K 10K 4 0.25
SYN-2 150K 25 20 1K 10K 4 0.25
SYN-3 150K 25 20 4K 10K 4 0.25
TABLE III. PARAMETER SETTINGS OF THRESHOLDS
? ? ?
S1 3.5 3% 100K
S2 4 3.5% 120K
S3 4.5 4% 150K
The first test we compare the total execution time with FP-
growth. For each threshold setting, the proposed algorithm 
spends 1.42 times more than FP-growth on average. This is a 
reasonable result since we need three database scans whereas 
FP-growth needs only two database scans to find complete set 
of patterns. 
Next, we compare the number of patterns generated from 
RFMP-growth and FP-growth. All three threshold settings are
considered here. As shown in table IV, we find that the number 
of patterns significantly decrease when three constraints are 
added. On average, our method prunes more than 55 percent of 
patterns. We further examine the revenues both two kinds of 
patterns can represent, and the result is promising. Although 
RFM-patterns retain less than 45 percent of patterns, the 
proportion of the revenue of RFM-patterns to that of traditional 
patterns is more than 64 percents. Moreover, we conduct the 
same test using real-life dataset. In Table V, the result show 
that our method outputs only 7 percent of traditional patterns 
but the revenue of these patterns is over 12 percents. In
TABLE IV. THE PROPORTION OF THE REVENUE OF RFM-PATTERNS TO 
THAT OF TRADITIONAL PATTERNS. (SYNTHETIC DATASETS)
patterns al traditionof #
patternsRFM of # 
patterns) aditionalRevenue(tr
patterns)MRevenue(RF 
S1 S2 S3 S1 S2 S3
SYN-1 47.21% 42.96% 39.34% 74.99% 71.31% 64.62%
SYN-2 55.13% 55.33% 52.23% 77.42% 80.46% 77.21%
SYN-3 35.16% 35.90% 32.91% 62.12% 43.52% 28.93%
TABLE V. THE PROPORTION OF THE REVENUE OF RFM-PATTERNS TO 
THAT OF TRADITIONAL PATTERNS. (REAL-LIFE DATASETS)
patterns al traditionof #
patternsRFM of # 
patterns) aditionalRevenue(tr
patterns)MRevenue(RF 
R0.05-F1%-M10k 6.90% 14.68%
R0.05-F0.5%-M10k 6.69% 10.26%
R0.005-F0.5%-M10k 7.62% 11.49%
R0.005-F0.6%-M12k 6.98% 11.39%
summary, through setting recency, frequency, and monetary 
thresholds simultaneously, we can get more compact, 
representative and useful patterns. 
VI. CONCLUSION
In this study, we consider the concept of RFM analysis into 
frequent pattern mining. To truly reflect the spirit of RFM in 
the mining process, we first define RFM-patterns, which can 
dynamically give recency score to each transaction, and 
perform the concept of monetary similar to utility mining. To 
efficiently discover RFM-patterns, we propose a tree structure 
(RFMP-tree) as well as the pattern growth method (RFMP-
growth) to discover complete set of RFM-patterns.  
Three synthetic datasets and a real-life dataset are used in 
experimental evaluation. The experimental results show that 
the proposed method can not only significantly reduce the size 
of outputted patterns, but also retain more meaningful results to 
users. 
REFERENCES
[1] F. Bonchi and C. Lucchese, "Extending the state-of-the-art of constraint-
based pattern discovery," Data & Knowledge Engineering, vol. 60, pp. 
377-399, 2007. 
[2] J. Pei, J. Han, and W. Wang, "Constraint-based sequential pattern 
mining: The pattern-growth methods," Journal of Intelligent Information 
Systems, vol. 28, pp. 133-160, 2007. 
[3] A. Hughes, Strategic database marketing, 3 ed.: McGraw-Hill 
Companies, 2005. 
[4] F. Wu, Y.-S. Lee, and J.-N. Yu, "An adaptive approach for model 
selection with high stability," in Proceedings of International Joint 
Conference on e-Commerce, e-Administration, e-Society, and e-
Education, Bangkok, Thailand, 2008. 
[5] G. Dong and J. Li, "Efficient mining of emerging patterns: Discovering 
trends and differences," in Proceedings of the 5th ACM SIGKDD 
International Conference on Knowledge Discovery and Data Mining,
San Diego, California, United States, 1999, pp. 43-52. 
[6] Y. Liu, W.-k. Liao, and A. Choudhary, "A two-phase algorithm for fast 
discovery of high utility itemsets," in The 9th Pacific-Asia Conference 
on Knowledge Discovery and Data Mining, Hanoi, Vietnam, 2005, pp. 
689-695. 
[7] C. F. Ahmed, S. K. Tanbeer, B.-S. Jeong, and Y.-K. Lee, "An efficient 
candidate pruning technique for high utility pattern mining," in 13th 
Pacific-Asia Conference on Knowledge and Data Mining, Bangkok, 
THAILAND, 2009, pp. 749-756. 
[8] Y.-L. Chen and Y.-H. Hu, "Constraint-based sequential pattern mining: 
The consideration of recency and compactness," Decision Support 
Systems, vol. 42, pp. 1203-1215, 2006. 
[9] Y.-L. Chen, M.-H. Kuo, S.-Y. Wu, and K. Tang, "Discovering recency, 
frequency, and monetary (RFM) sequential patterns from customers' 
purchasing data," Electronic Commerce Research and Applications, vol. 
8, pp. 241-251, 2009. 
[10] J. Han, J. Pei, Y. Yin, and R. Mao, "Mining frequent patterns without 
candidate generation: A frequent-pattern tree approach," Data Mining 
and Knowledge Discovery, vol. 8, pp. 53-87, 2004. 
427
