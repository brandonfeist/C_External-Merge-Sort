Incremental mining alogorithm Pre-FP in association rules based on FP-tree 
 
LIU Jian-ping, WANG Ying, YANG Fan-ding 
The College of Informatics & Electronics 
Zhejiang Sci-Tech University 
Hangzhou, China 
liujp@hzcnc.com 
 
Abstract—At present, most of association rule mining are static 
mining algorithms. However, in real Web applications, new 
transactions are usually incrementally inserted into database, 
the previous algorithms  couldn’t satisfy the rapid growth like 
this. In this paper, we proposed the incremental mining 
algorithms called Pre-FP based on PUFP-tree and Per-large-
itemsets. This algorithm don’t need rescan the original 
database when the new transactions surpass the fixed 
threshold , especially when each time the small fraction of 
transactions are inserted, Pre-FP can achieve a good execution 
efficiency for renewing construction of frequent pattern tree. 
Key words: Data Mining; web usage mining;  association 
rule;  incremental mining  
I. INTRODUCTION 
   Association rule mining is important in many data 
mining tasks. Since people like Agrawal proposed this 
concept[1], researches that related to association rule mining 
are always very active. The previous association rule mining 
algorithms, such as Apriori, FP-growth mining algorithms 
and so on, are all based on the same premise----the tuples in 
database are not changed. But in real conditions, transaction 
database will renew a lot of new transactions everyday. In 
this case, the association rules which are mined from the 
original database may be invalid, or there will be new 
association rules produced. The incremental updating 
algorithm of association rules (maintenance algorithm) is 
used to tell us how to mine the association rules efficiently 
when the premise is not successful. The key point to make 
these algorithms efficient lies in using the existing results of 
mining as many as possible to produce the small candidate 
itemsets or reduce the times of scanning the database. Now 
most of incremental updating algorithms are the 
improvement and optimization which take Apriori 
algorithms as core. For example, Cheung proposed a 
incremental mining algorithm called Fast-Up-Data (FUP)[2] 
in 1996. FUP algorithms improved on the basis of the 
Apriori algorithm and used the branch cut technique of 
Direct Hashing and Pruning(DHP)[3]. First, it mined the 
frequent itemsets from the additional tansactions, then, 
compared them with the ones that mined from the tansaction 
database before.  According to the results of comparing, FUP 
decided that if the whole tansaction database needed to be 
rescanned. The above procedure dramatically reduced the 
time of renewing the association rules.  
  Although FUP achieved the idea of incremental mining, 
however, in some certain conditions, the algorithms still need 
to rescan the original database. Hong[4] proposed a new Pre-
large-itemsets algorithm which can reduce the times of 
rescanning the original database in 2001. The algorithm used 
two different support threshold, “lower” and “upper”, to 
define the frequency of item for the first time. This algorithm 
doesn’t need rescan the original database when the database 
is growing, unless there are a lot of new tansactions coming 
out, thus, Pre-large-itemsets algorithm greatly reduced the 
time of the renewing association rules. 
In order to achieve the idea of FUP algorithm, Hong, Lin 
and Wu[5] designed a new FUFP-tree on the basis of FP-tree 
to improve the efficiency of processing the tree 
reconstruction after adding the new tansactions into the 
original database. In this paper, we proposed a new 
incremental mining algorithm called Pre-FP which was 
based on PUFP-tree and Per-Large-Itemsets[4]. This 
algorithm refered Pre-large-itemsets to define two support 
threshold to solve the problem that inconsistent frequency of 
the new itemsets in the original database and the new 
tansaction sets. Pre-FP can renew association rules all the 
time and doesn’t need to rescan the whole database in the 
process of database growth. Unless the amount of the 
emergence of new tansactions is greater than a set threshold, 
this threshold depends on the size of the two support 
threshold and database. 
II. THE INTRODUCTION OF RELATED 
TECHNOLOGY 
A. FUFP-tree 
The construction algorithm of FUFP-tree is almost the 
same as FP-tree, the only difference is that the links between 
parent nodes and child nodes are bi-directional. The 
improvement is able to quickly find the nodes which should 
be removed in the process of renewing FUFP-tree. In 
addition, all the frequent items and their support counts need 
to be saved in the item header tables. 
FUFP-tree must complete before adding the new 
tansactions , after adding the new tansactions, the renew 
programs of FUFP-tree will renew FUFP-tree with adding 
the new tansactions while don’t need to rescan the original 
database. The new items will be divided into four parts 
according to the frequency in the original database and the 
additional new tansaction sets , every part will be renewed 
into FUFP-tree through the different processes.  
During the process of renewing FUFP-tree, after an 
original frequent item became infrequent, it will be removed 
from FUFP-tree directly, then, its parent nodes and child 
nodes will be linked with each other. Corresponding, after an 
original infrequent item became frequent for adding the new 
2010 First International Conference on Networking and Distributed Computing
978-0-7695-4207-2/10 $26.00 © 2010 IEEE
DOI 10.1109/ICNDC.2010.49
199
transaction sets, its support usually surpassed support 
threshold a little, thus, it can be added into the end of the 
item header table. FUFP-tree need to be rebuilt once time 
only if the original database increased many tansactions. The 
updating method greatly improved the efficiency of FUFP-
tree update algorithm and saved a lot of time of rebuilding 
trees. 
B. Pre-large-itemsets  
T.P.Hong and Y.H.Tao first proposed using the two 
support threshold called “lower” and “upper” to define a new 
sort of itmset—Pre-large-itemsets in the documents[4]. The 
definition of upper threshold is the same as that in the 
general mining algorithms. The definition of lower  threshold 
is the minimum support threshold of Pre-large-itemsets. If 
the support count of an item is less than lower, the item is 
considered to be infrequent. Pre-large-itemsets are 
considered to be a buffer pool in the process of the 
incremental mining to reduce the repeated operations which 
changes the frequent item into infrequent item, and vice 
versa. 
After defined the two support threshold, the original 
database that is added new transaction sets can be expressed 
as 9 kinds of situations. The specific classifications are 
shown in Fig.1, the properties of each case ’s frequency are 
presented as follows: 
a) An itemset is frequent in both D and T. This kind of 
item set must be frequent in D T? . 
b) An itemset X is frequent in D, but it is infrequent in 
T. This kind of itemset may be frequent in D T? . The 
support of itemset in D is known , we only need to obtain the 
support of the itemset in T, then, through calculating if the 
inequality  . . ( )D TX count X count upper D T+ ? × + is 
successful, so we can decide its frequency in D T? . 
c) An itemset is infrequent in D while it is frequent in 
T. This kind of itemset may be also frequent in D T? . The 
support of itemset in T can be gotten directly, but the support 
of itemset in D needs to rescan D. At last, the itemset is 
decided if it is frequent in D T?  by calculating. 
d) An item set is infrequent in both D and T. This kind        
of item set must be infrequent in D T? . 
 
Figure 1.  9 kinds of situations of the renewed original database 
Obviously, weighted counts in situation 1, 5, 6, 8, 9 can’t 
affect the association rules mined. Situation 2, 3 may reduce 
the existing association rules. Situation 4, 7 may increase the 
new association rules. If we save frequent itemsets, Pre-
large-itemsets and their support counts after renewed every 
time , the results of Situation 2, 3, 4 will be relatively easy to 
calculate. In the whole process of renewing, compared with 
original transaction sets, the additional transaction sets are 
generally very small, especially when the original database is 
increasing very quickly. The items of situation 7 in the 
renewed transaction database can’t change to be frequent 
items unless the number of transactions in the additional 
transaction sets surpasses f, f is defined as following[4]:  
 
( )
1
u l
u
dS S
f
S
?
=
?
? ?? ?? ?     
f  is called as the safety threshold of the new transaction 
sets, uS is upper threshold, lS is lower threshold, d is the 
number of transaction in the original database. The 9 kinds 
of situations above and their renewed results are in Table 1. 
 
TABLE I.  THE 9 KINDS OF SITUATIONS AND THEIR RESULTS 
 
III. INCREMENTAL MINING ALGORITHM PRE-FP 
The impoved algorithm in this paper will use the tree 
structure of FUFP-tree and the theory of Pre-large-item. 
FUFP-tree in the original transaction database must be 
finished before adding the new transactions. It used the same 
method of building FP-tree. First, scan the whole transaction 
database, find frequent 1-itemsets by Pre-defined minimum 
support threshold. Then, frequent 1-itemsets are arranged in 
descending order. Finally, rescan transaction database, 
construct FUFP-tree by frequent items in frequent 1-
itemsets. The whole process is building in transactions, when 
all the transactions were completed, the building is over. In 
addition, define another variable c in order to record the new 
additional transactions since rescanned the original data sets 
Situations?original database –
new tansaction sets Renewed results 
situation1:Frequent-Frequent Frequent 
situation2 :Frequent–Pre-large Need to judge frequent or Pre-large from specific cases 
situation3:Frequent– infrequent 
Need to judge Frequent?Pre-
large or infrequent from specific 
cases 
situation4:Pre-large–Frequent Need to judge Pre-large or Frequent from specific cases 
situation5 :Pre-large–Pre-large Pre-large 
situation6 :Pre-large–infrequent Need to judge Pre-large or infrequent
situation7:infrequent–frequent 
When the number of additional
tansactions is less than f, it is 
infrequesnt or Pre-large. 
situation8 :infrequent–Pre-large Infrequent or Pre-large 
situation9 :infrequent–infrequent Infrequent 
200
last time. The marks which are used in Pre-FP algorithm are 
shown in Table 2. 
 
TABLE II.  MARK THE DEFINTIONS 
Marks Definition 
D original database 
T new additional transaction sets 
U Renewed transaction database?for example, D d?   
d The number of transactions in D 
t  The number of transactions in T 
St  support threshold of Lower 
Su  support threshold of upper 
I  Items 
( )D IS   support count of I in D 
( )T IS  support count of I in T 
( )U IS  support count of I in U 
Insert_Items itemsets which need to update into FUFP-tree in T 
Branch_Items itemsets which need to update into FUFP-tree in D 
Rescan_Items 
the itemsets which need to rescan the whole 
original transaction database to decide if 
they are frequent. 
 
The algorithm is described as follows: 
Input: a tansaction database which has ( )d c+  
transactions, item header table which saved frequent 1-
itemsets in descending order, corresponding FUFP-tree, 
support threshold of lower lS , support threshold of upper uS , 
Pre-large-item list which is used to save Pre-large-items of 
original transaction database, the new transaction sets which 
have t transactions. 
Output: a updated FUFP-tree. 
Step 1: According to the formula
( )
1
u l
u
dS S
f
S
?
=
?
? ?? ?? ? , we 
can calculate the safety threshold f of the new transaction 
sets. 
Step 2: Get all the item and their support through 
scanning the new transaction sets. 
Step 3: the items in new transaction sets are sorted into 
frequent, Pre-large and infrequent by their support in the 
original transaction database 
Step 4: For item of I which was generated in Step 3, if it 
is frequent in the original transaction database (the elements 
in the item head table), execute the following 
steps(Corresponds to the situation1, 2 and 3 in Fig.1): 
Substep 4.1: The support of I in the renewed transaction 
database is updated into,    ( ) ( ) ( )U D TI I IS S S= + ? ( )D IS is 
the support of I in the renewed transaction database, ( )T IS is 
the support in the new transaction sets. 
Substep 4.2: If ( ) / ( )U UI d c tS S+ + ? , the support 
count of I in the item header table will be updated 
into ( )U IS , and I is put into Insert_Items, it will be 
processed in step 10. If ( ) / ( )UU lI d c tS S S? + + ? , I will 
be removed from the item header table, the parent nodes and 
child nodes of I are linked in FUFP-tree, set ( ) ( )D UI IS S= , 
and save I and its support count ( )D IS in the Pre-large item 
list. If ( ) / ( )U lI d c tS S+ + ? , I  will be removed from the 
item header table, the parent nodes and child nodes of I are 
linked in FUFP-tree . 
Step 5: For the item I which was generated in Step 3, if it 
is Pre-large in the original transaction database, execute the 
following steps (Corresponds to the situation4, 5 and 6 in 
Fig.1): 
Substep 5.1: the support of I in the updated transaction 
database is : ( ) ( ) ( )U D TI I IS S S= +  
Substep 5.2: If ( ) / ( )U UI d c tS S+ + ? , item I became 
frequent after the original transaction database updated, put I 
into Insert_Items and Branch_Items, it will be processed in 
step 8. If ( ) / ( )UU lI d c tS S S? + + ? , set ( ) ( )D UI IS S= , 
and save I and its support ( )D IS  into the Pre-large table. If 
( ) / ( )U lI d c tS S+ + ? , I will be removed from the Pre-
large table. 
Step 6: For the item I which was generated in Step 3?if 
it is infrequent in the original transaction database while it is 
frequent or Pre-large in the new transaction sets (situation 7 
and 8 in Fig.1), put I into Rscan_Items, these items will be 
used in rescanning database in step 7. 
Step 7: If t c f+ ? or Rscan_Items is null, do no action; 
else operate the item I in Rscan_Items as followings: 
Substep 7.1: rescan the original database to calculate the 
support count of I called ( )D IS . 
Substep 7.2: the support of I in the renewed transaction 
database is ( ) ( ) ( )U D TI I IS S S= + . 
Substep 7.3: If ( ) / ( )U UI d c tS S+ + ? , I becomes 
frequent item after renewed the original transaction database, 
put I into Insert_Items and Branch_Items. If 
( ) / ( )UU lI d c tS S S? + + ?  , and save I and its support 
( )D IS  in the Pre-large table. If ( ) / ( )U lI d c tS S+ + ? , do 
no action. 
Step 8: put the items in Branch_Items into the end of the 
item header table, they are sorted in descending order in the 
new support count. 
Step 9: For the item I in Branch_Items which has already 
been exsited in the original transaction database, if I doesn’t 
appear in the corresponding transaction branch in FUFP-tree, 
put I into the end of transaction branch, and set the support 
count of I as 1, else add 1 into the support count of I . 
Step 10: the item I in Insert_Items which appeared in the 
new transaction sets, if I doesn’t appear in the corresponding 
transaction branch in FUFP-tree, put I into the end of the 
new transaction branch,  and set the support count of I as 1, 
else add 1 into the support count of I . 
201
Step 11: if t c f+ > , set d d t c= + + , 0c = ; else  
c t c= + . 
In step 9, the corresponding transaction branch is the 
branch which is generated by frequent items in every 
transaction according to the sequence in the item header 
table. After step 11 is executed , a new FUFP-tree is built 
through Pre-FP Update Algorithm, the new transaction sets 
have already added into the original transaction database to 
form a new transaction database. According to the new 
generated FUFP-tree, we can mine the association rules by 
FP-growth algorithm[6]. 
IV. EXPERIMENTAL ANALYSIS OF   
ALGORITHMS 
In this segment, we use FP-tree, FUFP-tree and Pre-FP 
separately to mine the transaction database. Every time the 
new transaction sets are produced, the FP-tree algorithm 
adds the new transaction sets to the original database, and 
then reconstruct the FP-tree. But the incremental mining 
algorithm, FUFP-tree and Pre-FP, deal with the new 
transaction sets in incremental way with the existing mining 
results. 
In order to show the results of the improvement, the 
mining date source used a larger log sample from online 
shopping system of Zhejiang Sci-Tech university campus 
network sites. 
The experiment is divided into two parts, in the first test, 
pick the top 10000 transactions from the transaction database 
to construct FP-tree. The minimum support threshold is set 
to 1%-5%, and increases 1% every time, the three kinds of 
algorithms are compared, then, 800 transactions which are 
supposed as a new additional transaction sets are used to 
simulate the growth of database. The upper threshold of Pre-
FP algorithm is set to 1%-5% which add 1% every time, the 
lower threshold is set to 0.5%-2.5% which add 0.5% every 
time. The execution time of the three algorithms in different 
support threshold is shown in Fig.2.  
 
 
Figure 2.  the comparison of execution time under the different support 
threshold 
From Fig.2 we can see the time-consuming of the FP-tree 
is much more than the other two incremental algorithms, 
because after the new transaction was added to database 
every time, FP-tree must be reconstructed, which consumes a 
lot of time. The execution time of Pre-FP is superior to 
FUFP-tree, because the times that Pre-FP rescans the whole 
transaction database are less than FUP algorithm. With this 
in mind, the new increased nodes are always added into the 
end of the item header table, the updated tree structure of 
Pre-FP updating algorithm may be different from the one 
that is reconstructed by using FP-tree construction algorithm. 
The effectiveness of Pre-FP is shown in Fig.3, we can see the 
number of nodes which are generated by the three kinds of 
algorithms is almost the same, so the tree structure that can 
be constructed is basically same. So we can conclude that the 
validity of Pre-FP algorithm is acceptable. 
 
 
Figure 3.  comparison of the number of nodes under the different support 
threshold 
The second test is used to compare the execution time 
and the number of generated nodes of the three kinds of 
algorithms under the different numbers of the new 
transaction sets. The minimum support threshold of FP-tree 
and FUFP-tree algorithm is set to be 4%, Pre-FP algorithm 
upper and lower thresholds are set to be 4% and 2% 
separately. Pick the top 10000 transactions from the 
transaction database to construct FP-tree, in the rest 
transaction sets, we take a group for every 800 as a new 
transaction sets to add into the original transaction database. 
The results of the experiment are shown in Fig.4 and Fig.5. 
Noting that in Fig.4, with the emergence of the new 
transaction sets and the growth of the original transaction 
database, compared to FUFP-tree algorithm, the advantages 
of the Pre-FP algorithm are more and more obvious. Because 
with the original database increasing, according to the 
formula
( )
1
u l
u
dS S
f
S
?
=
?
? ?? ?? ? , f will  also increase 
continuously, which means that more new transactions can 
be added without rescanning the transaction database. With 
the growth of the transaction database, the relative efficiency 
of Pre-FP algorithm will become increasingly evident, this 
feature is very ideal for the rapid growth of the Web usage 
mining. The results of the experiment for Fig.5 show that 
with the transaction database increasing, the numbers of 
nodes which are generated by the three kinds of algorithms 
are almost the same, which proved the effectiveness of the 
algorithms under different growth amplitudes of the 
database. 
202
Through the experiments above, we can prove that the 
execution efficiency of Pre-FP is much higher than the 
traditional static mining algorithm PF-tree, comparing to the 
existing incremental mining algorithm FUFP-tree, Pre-FP 
also have some advantages, and its validity is as good as the 
other two algorithms. 
 
Figure 4.  Comparison of the execution time of adding new transaction 
sets continuously 
 
Figure 5.  Comparison of the generated nodes of adding new transaction 
sets continuously 
V. CONCLUSIONS 
This paper proposed a kind of new incremental mining 
algorithm Pre-FP based on the theory of Pre-large-itemsets, 
its main idea is that through predefined the two support 
threshold “upper” and “lower”,  set a Pre-large itemsets 
besides the frequent itemsets and the infrequent ones, when 
the new transaction sets are adding, the frequent items don’t 
be transformed into infrequent ones or the infrequent items 
don’t be transformed into the frequent ones directly, but the 
items are put into Pre-large itemsets first. This method 
reduced the times of rescanning the original transaction 
database. 
On the basis of the experiment, made a comparison 
between Pre-FP algorithm and the other two algorithms in 
the performance and the results of mining, the experimental 
results show that Pre-FP algorithm has shorten the execution 
time and has no difference in the results of implementation 
compared to FP-tree and FUFP-tree, it achieved a good 
balance between the execution time and the structural 
complexity . 
REFERENCES 
[1] R.Agrawal, T.Imielinski and A.Swami. Mining  association rules 
between sets of items in large database[C]. The 1993 ACM-
SIGMOD, Washington, USA, 1993: 207~216. 
[2] D.W.Cheung, J.Han. Maintenance of discovered association rules in 
large databases: an incremental updating approach[C]. In The twelfth 
IEEE international conference on data engineering, 1996:106~114. 
[3] J.S.Park, M.S.Chen and P.S.Yu. Using a hash-based method with 
transaction trimming for mining association rules [J]. IEEE 
Transactions on Knowledge and Data Engineering, 1997: 812~825. 
[4] T.P.Hong, J.W.Lin and Y.H.Tao. A new incremental data mining 
algorithm using pre-large itemsets [J]. Intelligent Data Analysis, 
2001,  5(2), 111~129. 
[5] T.P.Hong, J.W.Lin and Y.H.Wu. A fast updated frequent pattern 
tree[C]. In The IEEE International conference on systems, man and 
cybernetics, 2006: 2167~2172. 
[6] J.Han, J.Pei and Y.Yin, Mining frequent patterns without candidate 
generation[C]. The 2000 ACM-SIGMOD, Dallas, USA, 2000. 
 
 
 
 
203
