Simulation Data Analysis and Study of CQMAR Algorithm 
QingXue 
Academy of Armored Force Engineering 
Beijing, China 
E-mail: fengyuI124@163.com 
Abstract-The classification and the need of association rules 
have been outlined, for the analysis of simulation data, this 
article has proposed CQMAR algorithm (CAlM and 
Quantitative Matrix Algorithm for Association Rules 
Analyzing), which only scans the database once, and can 
handle multi-value data. CQMAR algorithm has a strong 
practical effect, which improves the timeliness and accuracy of 
analysis, and has important reference value for simulation data 
for analysis and summary of findings. 
Keywords-association rules; simulation datil; AQMAR 
algorithm; Apriori algorithm; 
I. INTRODUCTION 
Association is a class of important regularities which can 
be found between two or more variables. Association rules 
analyzing is that interesting correlation between itemsets or 
related links are found in large amounts of data. Association 
rules in data analysis are an important issue. Association 
rules are classified according to different situations: Rule­
based categories of the variables in the processing, 
association rules can be divided into Boolean and multi­
value type; Rule-based level of abstraction of data, 
association rules can be divided into single-association rules 
and multi-association rules; Rule-based data involved in 
dimension, association rules can be divided into one­
dimensional and multi-dimensional [1]. 
II. CQMAR ALGORITHM 
Association rules analyzing is to find the hidden rules of 
the simulation database. For the main issues of association 
rules analysis, this article focuses on studying how to get 
frequent item sets, and introduces the association rules 
algorithm which is based on CAlM [2] and multi-valued 
matrix algorithm CQMAR algorithm (CAlM and 
Quantitative Matrix Algorithm for Association Rules 
Analyzing), the algorithm introduces the concept of matrix 
model, and that the classic Apriori [3] algorithm is different 
and only needs to scan the database once, which can handle 
multi-value data strong practically. 
A. Thinking for Algorithms 
Definition 2.1 Suppose X is a frequent pattern set, if X is 
not all super-set of frequent, then X is called a maximal 
frequent item sets (maximal frequent itemset) or maximal 
frequent patterns (maximal frequent pattern). 
978-1-4244-6585-9/10/$26.00 ©2010 IEEE 
474 
Fei Yun, Shaoliang Zhou 
Academy of Armored Force Engineering 
Beijing, China 
E-mail: fengyul124@163.com 
Property 2.1:  The real supersets of the maximum 
frequent itemsets are not any frequent. 
Property 2.2 : All non-empty sets of the maximum 
frequent itemsets are frequent. 
Through the Property 2.1 and Property 2.2, we can see 
the maximum frequent itemsets are the dividing line between 
non-frequent itemsets and frequent itemsets. Maximal 
frequent pattern sets in the following are frequent patterns, 
maximum frequent pattern sets over are all non-frequent 
pattern. Therefore, as long as finding all the maximal 
frequent patterns, you can get all the frequent patterns by all 
the frequent subsets [4]. These two properties are important 
basis for this article. 
B. Improvement of the Boolean Matrix Algorithm 
Use CAlM algorithm in literature [2] instead the 
numerical attribute values of interval. And, compared with 
the Boolean association rules, which transforms multi-valued 
association rules directly , this article does not limit the 
number of time interval after dispersing, so that it ensures 
data compatibility and consistency after discretization in the 
maximum extent, reducing the loss of information. 
• Creating the Pattern Matrix 
Definition 2.2: Set up that itemset 1= {ip i2, ••• , iJ ' the 
transaction set D = {II' 12, ••• , 1m}' then the pattern matrix is 
generated as follows [5]: each element of matrix P {Pij} is 
defined as follows: 
{I, 
Pij 
= 
0, 
'liij Eli' 
'liij ? Ii' 
There, i =  1,2, ... , m; j = 1, 2, ... , n. 
(2-1) 
Set up a database containing n matters. All matters 
involves m items, then the corresponding pattern matrix can 
be considered to be composed of the m-column vector of n, 
Yi denotes the ith column vector, Y ij denotes the i-jth item 
in the emergence 0 f affairs or not, if appearing, there is Y ij = 
I, otherwise Yij = O. 
Each line of matrix P for the same pattern can be 
considered as vectors Xi' Xi denotes the ith column vector, 
xij denotes the i-jth item in the emergence of affairs or not, 
if appearing, there is xij = 1, otherwise xij = O. 
For example: Set up I = {A,B,C,D,E,F} , tmnsaction 
database tl ={A,B,C} , t2 ={A,C,D} , t3 ={A,B,E,F} , 
t4 ={A,B,C,D,F} , t5={B,C,D,E). Matrix is genemted: 
1 1 1 0 
1 0 1  1 
p= 1 1 0 0 
1 1 1 1 
o 1 1 1 
o 0 
o 0 
1 1 
o 1 
1 0 
(2-2) 
Therefore, the type (2-2) can also be expressed as: 
Yl Y2 Y3 Y4 Ys Y6 
XI 1 1 1 0 0 0 
x2 1 0 1 1 0 0 
P= x3 1 1 0 0 1 1 
x4 1 1 1 1 0 1 
X5 0 1 1 1 1 0 (2-3) 
• Creating Frequent Itemsets 
Through the formation of pattern matrix, scan the 
database once and get pattern matrix P, we will operate the 
database through operating on P, and get frequent itemsets 
by computing the column vector Yi . Set the minimum 
support for the Smin = a%, SUP is the number of 1 in the 
vector. According to the definition of frequent item sets, we 
take bitwise opemtion for the vector Yi' if the SUP value is 
not less than s in the results, then the items set corresponding 
to the vector shall be frequent itemsets; if less than s, then 
the items set must not be a frequent item set and we remove 
it. Continue to build pattern matrix after making opemtions 
on the vector retained, and as with the opemtion, repeat the 
above work, until the pattern matrix leave only one row or to 
be O. Finally, through all saved vector, output its 
corresponding itemsets, namely frequent itemsets L. 
• Genemte Association Rules through Frequent 
Itemsets 
After getting frequent itemsets L, genemte association 
rules from it, the geneml form is {X ? R - X}, measure 
of association rules is the support s and confidence c, where 
X, R must be frequent itemsets, and Xc R; X, R E L , 
requires ? Smin' C ? Cmin· 
Read all X and R meeting the conditions of X C R from 
the L, and calculate confidence con/(X ? R - X) . If 
con/(X ? R - X) exceed Cmin ' then produce 
X ? R - X as a rule. 
475 
C. Propose the Algorithm 
This section focuses on the how to get association rules 
of frequent item sets, the Boolean matrix method is the basis 
for CQMAR algorithm whose purpose is to transform from 
the multi-valued attribute matrix to a Boolean matrix for 
further operations. Literature [3] presents method of 
association rules algorithm to deal with Boolean matrix in 
the Apriori, this section has given the algorithm for 
tmnsforming the multi-value matrix to the Boolean matrix 
algorithm based on discrete CAlM [2]. First, two definitions 
are given: 
Definition 2.3 The sub-vector Djp of vector Dj is defined 
as: Djp = (d1jp, d2jp, ... , dijp, ... , dmjp) T, where dijp denotes p-bit 
value in row j column i of the matrix. 
Definition 2.4 : The length of the vector Dj is 
represented by 1 Dj I, namely Dj domain width. 
Table 2-1 is a typical mixed-attribute decision table, 
which contains both discrete attributes and continuous 
attributes, so the data should be discretized. Use CAlM [2] 
algorithms to discrete Tab Ie 2 -1, then, get the decision tab Ie 
after discretization, as shown in Table 2-2: 
TABLE I. THE REBUILDED DECISION TABLE 
C D 
U Subhead Roadc2 Weather Numberof Damage 
speed Cl C3 people C4 rate d 
1 4.62 9 sunny 42 1.98 
2 8.63 4 cloudy 18 20.30 
3 11.51 8 sunny 12 3.68 
4 3.55 3 sunny 12 4.25 
5 7.35 4 sunny 16 3.14 
. . .  . , .  . . .  . . .  . . . . .  . 
TABLE II. DECISION TABLE AFTER DISCRETIZATION 
C D 
U Speed Roadc2 Weather Numberof Damage 
Cl C3 people C4 rate d 
1 1 2 1 3 1 
2 2 1 2 2 2 
3 3 2 1 1 1 
4 1 1 1 1 1 
5 2 1 1 2 1 
. . . . .  , ' "  . . .  . . .  . . .  
DIscrete attrIbutes for codmg based on Table 2-3: 
TABLE III. GIST OF ATTRIBUTES ENCODING FOR DECISION TABLE 
Serial Coding 
Numb Attribute 
er 1 2 3 
1 Speed Cl [2.56,5.16] [5.89,9.35] [9.55,12.1 2] 
2 Road C2 [3,5] [6,9] 
3 Weather C3 sunny cloudy 
4 Number of [7,13] [15,26] [33,46] 
people C4 
5 Damage rate [1.67,8.98] [18.49,27.65] [31.25,44. 
d 68] 
Get various divided intervals and their corresponding 
codes, Boolean code: if code number is 2, Use 0 and 1 
encoded directly; if code number is greater than 2, Boolean 
length of the field after a set of values of the data can be 
number (that is the domain width in the definition 2.4), each 
of the value is 0 or 1, the position of 1 is decided by the 
corresponding data. Take the discrete data encoding in the 
table 2-3 for example, Boolean encoding is in the following 
table: 
TABLE IV. BOOLEAN DISCRETIZATION OF ATTRIBUTES ENCODED 
Serial Attribute 
Coding 
number I 2 3 
I Speed Cl 100 010 001 
2 Road C2 0 I 
3 Weather C3 0 I 
4 Number of 100 010 001 
people C4 
5 Damage rate d 100 010 001 
The Data after Boolean Encodmg IS shown m Table 2-5: 
TABLE V. DECISION TABLE AFTER BOOLEAN ENCODING 
C D 
U Speed Roadc2 Weather Number of Damage 
Cl C3 people C4 rate d 
I 100 I 0 001 100 
2 010 0 I 010 010 
3 001 I 0 100 100 
4 100 0 0 100 100 
5 010 0 0 010 100 
Scan Table 2-5 and get the followmg matrix: 
YI Y2 Y3 Y4 Ys 
Xl 1 00 1 0 00 1 1 00 
x2 0 1 0  0 1 0 1 0  0 1 0  
P= x3 00 1 1 0 1 00 1 00 (2-4) 
x4 1 00 0 0 1 00 1 00 
Xs 0 1 0  0 0 0 1 0  1 00 
Making Yb Y4, Ys in the type (2-4) reclassified in 
accordance with each sub-vector can obtain the following 
matrix: 
Yll Y12 Y13 Y2 Y3 Y41 Y42 Y43 Y51 Y52 Y53 
Xl 1 0 0 1 0 0 0 1 1 0 0 
X2 0 1 0 0 1 0 1 0 0 1 0 
P= X3 0 0 1 1 0 1 0 0 1 0 0 (2-5) 
x4 1 0 0 0 0 1 0 0 1 0 0 
Xs 0 1 0 0 0 0 1 0 1 0 0 
476 
The type (2-5) is matrix P transformed from the matrix, 
and then we can get the corresponding frequent itemsets. 
D. Algorithm Flow 
Algorithm 2.1 CQMAR algorithm 
Input: Information system S= <U, A, V, f) , where 
U is the universe of discourse U = {xl' x2' • • •  , xJ 
minimum support is S min . 
Output: frequent itemsets L. 
Step 1: Generating pattern matrix. 
Step 1.1: Discretization of the information system; 
Step 1.2: If discrete value is Boolean type, go to Step 1.4; 
if discrete value is multi-value type, go to 1.3; 
Step 1.3: The Boolean encoding of multiple values; 
Step 1.4: Scan the database once, get pattern matrix P; 
Step 2: Generate frequent 2 - itemsets. 
Step 2.1: First of all, calculate SUP of each column 
vector of the P, if SUP <s, then round the colunm vector; If 
SUP> s then save the column vector. At this time, preserved 
column vector corresponding to the items set shall be 
frequent 1 - itemsets; 
Step 2.2: According to the original model, re-combine 
the preservation of the colunm vector P into a matrix, then, 
we can get pattern matrix PI; 
Step 2.3: Operate on the colunm of PI for by-bit, and 
calculate SUP of operations results, if SUP <s then round the 
column vector, If SUP> s, then save the column vector. At 
this time, preserved column vector corresponding to the 
items set shall be frequent 2 - itemsets; 
Step 2.4: According to the original model, re-combine 
the preservation of the column vector of PI into a matrix, 
then, we can get pattern matrix P2; 
Step 3: Generate frequent k-itemsets. 
Step 3.1: first, Operate on the colunm of Pk-I for by-bit, 
and calculate SUP of operations results, if SUP <s then 
round the column vector, If SUP> s, then save the column 
vector. At this time, preserved column vector corresponding 
to the items set shall be frequent 2 - itemsets; 
Step 3.2: According to property 4.2, cut branch the 
preservation of the column vector P, the itemsets 
corresponding to the remaining column vector shall be 
frequent k-itemsets; 
Step 3.3: According to the original model, re-combine 
the preservation of the column vector from Step 3.2 into a 
matrix, then, we can get pattern matrix Pk; 
Step 3.4: If the pattern matrix only includes one column 
or Pk is empty, the algorithm end; otherwise repeat from Step 
3.1 to Step 3.3 until the pattern matrix only includes one 
column or Pk is empty. 
III. COMPARE CQMAR ALGORITHM WITH APRIORI 
ALGORITHM 
Through Apriori analysis from the literature [3], for 
CQMAR algorithm, we can compare and analyze these two 
algorithms in the following areas: 
A. Data type 
Apriori algorithm can only deal with Boolean data, for 
each property of the database it can only set a breakpoint and 
may result in loss of information. But, the CQMAR 
algorithm does not restrict attribute value type, and can keep 
the consistency of data. 
B. Time complexity 
Apriori algorithm needs to scan the database many times, 
repeats operation, the algorithm's time complexity 
is 0(1 D Ik+!) , I D I denotes the number of transactions the 
transaction database contains. The CQMAR algorithm only 
needs to scan the database once, time complexity 
is O( mk n) , and m denotes the number of row pattern matrix 
scan, n denotes the number of column for the pattern matrix 
after Boolean operation. In practice, for large transaction 
databases, in general the number of transactions is much 
larger than the number of items, that is IDI D n. Therefore, 
CQMAR algorithm has better time efficiency. 
C. Space complexity 
Apriori algorithm generates a large number of candidate 
itemsets, and all having the same length candidate items 
must be stored in memory, it will take up a lot of memory 
space, causing memory constantly change in-to for the 
operation. The CQMAR algorithm uses the matrix for 
storage, it is no longer use database operations, it has a 
significant reduction in the required I / 0 times and reduces 
477 
storage space, debug that, it does not need to store all the 
candidate itemsets in memory and it has good spatial 
characteristics . 
IV. CONCLUSION 
Based on study of the simulation data analysis of 
association rules, these article pointes out the necessity and 
significance of association rules, and then introduced 
CQMAR algorithm. The algorithm can reduce the times for 
database scanning of the data analysis process, and can 
analyze multi-value data association rules, numerical tests 
show that this algorithm can save time for data analysis of 
association rules, the algorithm is applied to the simulation 
data analysis, achieving good results. 
REFERENCES 
[I] Hongbin DONG, Zhi HE. Cooperative Evolutionary Algoritlun and 
its Application in Data Mining [M]. Beijing: China Water Power 
Press. 2008 . 
[2] Yipu Peng, Y ongjun Xiong. Mending AprioriTid algorithm in 
association rule mining [1]. Computer Applications, 2005, 25 (5): 
979-981. 
[3] Li Chao, Xiaoping Yu. Improving on Aprtori based on matrix 
algorithm[J]. Computer Engineering, 2006 (23):68-69. 
[4] Yuqing Miao. Association rule mining and its application in gene 
expression data [0]. China University of Science and Technology. 
2007. 
[5] Yubo Yuan, Chuansheng Yang, Ting-Zhu other. Data mining and 
optimization technology and its application [M]. Beijing: National 
Defence Industry Press. 2007. 
