Mining Association Rules: A Continuous Incremental Updating Technique
Siqing Shan, Xiaojing Wang, and Miao Sui
School of Economics and Management
Beihang University
Beijing, China
E-mail:shansiqing@buaa.edu.cn
AbstractüA continuous incremental updating technique is 
proposed for efficient maintenance of the mining association 
rules when new transaction data are added to a transaction 
database. FP-growth algorithm can mine the complete set of 
frequent patterns by pattern fragment growth. To efficient 
maintenance of the mining association rules, we improve the 
FP-growth algorithm in three aspects: 1) an optimization 
technique for reducing the database size during the update 
process is discussed, and 2) the construction algorithm of a 
transaction tree T-tree, and 3) the candidate pattern pools 
are proposed based-on the structure of T-tree. Then, a 
continuous incremental updating algorithm, or CIU 
algorithm for short, is proposed. Our performance study 
shows that the continuous incremental updating technique is
efficient and scalable for mining both long and short 
frequent patterns.
Keywordsüdata mining, association rules, continuous 
incremental updating technique, amalgamate transactions.
I. INTRODUCTION
One major application domain of data mining is in the 
analysis of transactional data. It is assumed that the 
database system keeps information about user transactions, 
where each transaction is a collection of data items. In this 
setting, association rules capture inter-relationships 
between various data items. In many situations, data 
mining is treated as a synonym of knowledge discovery in 
databases [4, 6, 7, 8, 10, 14]
Discovering association rules from a large amount of 
data sets has been a focused field in recent data mining 
research. Mining association rules from databases has the 
characteristics: 1) the size of the database is significantly 
large. 2) the rules mined is valid only in statistical terms. 3) 
the rules mined from a large database only reflect the 
current state of the database. 
The characteristics indicate that the promise of data 
mining lies in the techniques to handle a large amount of 
data, to manage a substantial number of rules, and to 
maintain the rules over a significantly long period of time. 
Hence, two problems are essential in order to make data 
mining a feasible technology. The two problems are: 1) 
design efficient algorithms for mining different types of 
rules or patterns, and 2) design efficient algorithms to 
update, maintain, and manage the rules mined [5].
The first problem has been studied substantially with 
many interesting and efficient data mining algorithms 
reported [1, 2, 3, 9, 12, 13, 15, 16, 18, 19, 20]. However, 
very little work has been done on the second problem. 
FUP algorithm, an incremental updating technique for 
maintenance of mining association rules in large databases, 
is proposed [5]. However, the FUP algorithm is based on 
Apriori algorithm. Although Apriori algorithm is a 
successful algorithm, it may suffer from the two nontrivial 
costs: 1) it may need to generate a huge number of 
candidate sets; and 2) it may need to repeatedly scan the 
database. 
To avoid generating a huge set of candidates, an 
efficient FP-tree-based mining method called FP-growth
is developed [11]. The FP-growth algorithm can mine the 
complete set of frequent patterns by pattern fragment 
growth. However, we think that FP-growth algorithm may 
still suffer from the nontrivial costs: it is costly that the 
frequent items are sorted in their frequency descending 
order. There are following three reasons.
First, it is nontrivial cost that the frequent items are 
sorted in their frequency descending order. In the 
FP-growth algorithm, it is believed that the FP-tree tree 
nodes are arranged in their frequency descending order 
will have better chances of sharing nodes than less 
frequently occurring ones and the FP-tree structure is 
usually highly compact. 
Second, sometimes it is impossible that the frequent 
items are sorted in their frequency descending order. In 
the FP-growth algorithm, the items in the transaction 
database have no their amount. However, if item amount 
is considered, it may be impossible that the frequent items 
are sorted in their frequency descending order. 
Last issue is how to incrementally update an FP-tree.
Because the structure of FP-tree is dependent on the 
frequency descending order, the structure of FP-tree must 
be reconstructed when the frequency descending order 
changes due to the adding of new transactions. 
In this paper, we study the problem of continuous 
incremental updating technique for maintenance of mined 
association rules. First, we construct a transaction tree, or 
T-tree for short. The T-tree structure is not dependent to 
the frequency descending order but is only dependent to 
2010 International Conference on Web Information Systems and Mining
978-0-7695-4224-9/10 $26.00 © 2010 IEEE
DOI 10.1109/WISM.2010.39
62
the order of serial number. Second, transactions in the 
primitive transaction database can be sequence 
amalgamated in certain regulations. Third, the concept of 
candidate pattern pool is proposed.
The remainder of the paper is organized as follows. 
Section 2 gives a brief review of the problem of mining
association rules and FP-growth algorithm. Section 3 
gives the description of continuous incremental updating 
algorithm. The optimization technique is also discussed in 
this section. Section 4 gives our performance study. 
Section 5 summarizes our study.
II. OVERVIEW OF FP-GROWTH ALGORITHM
We now present the basic concept about association 
rules and FP-growth algorithm [10, 11, 14]. 
A. Association Rules
Let I = {i1, i2, …, im
An association rule is an implication of the form X?Y,
where X?I, Y?I, and X?Y=¶. The rule X?Y holds in 
the transaction set D with confidence c if c% of 
transactions in D that contain X also contain Y. The rule X
?Y has support s in the transaction set D if s% of 
transactions in D contain X?Y.
} be a set of literals called items. 
Let D be a transaction database or a set of transactions, 
where each transaction T is an itemset such that T?I. We 
can say that a transaction T contains X, a set of some items 
in I, if X?T.
Given a set of transaction D, the problem of mining 
association rules is to generate all association rules that 
have certain user-specified minimum support, called 
min_sup, and minimum confidence, called min_conf.
The problem of mining association rules can be 
decomposed into two subproblems [1]: 1) Find all sets of 
items; and 2) Use the frequent itemsets to generate the 
desired association rules. 
B. FP-growth Algorithm
The main idea of FP-growth is mining frequent 
itemsets. The notation in FP-growth is given TABLE I.
TABLE 1 NOTATION USED IN FP-GROWTH ALGORITHM
Notation Description
D
T
F
L
null
[p|P]
N
£
¢
a
Transaction database.
i
A transaction in D.
The set of frequent items and their support.
List of frequent items in descending order.
The root of FP-tree.
List of sorted frequent item in T, where p is the 
first element, and P is the remaining
The child elements in T.
A combination of the nodes in path P.
The root of a FP-tree.
The leaf of a FP-tree.
The FP-growth algorithm and its related procedures 
are shown in Figure 1. In first phase, the structure of 
FP-tree is constructed. In second phase, the mining of a 
FP-tree is performed by FP-growth (Tree, ¢). 
Figure 1 The pseudo code of FP-growth algorithm
The advantage of FP-growth algorithm is without 
generating the huge amount of candidate itemsets. 
III. CONTINUOUS INCREMENTAL UPDATING
ALGORITHM
In this section, we first propose an optimization 
technique for reducing the database size. Second, we give 
the definition and algorithm of transactions tree, or T-tree
for short. Third, it is detail described that how to maintain 
the candidate pattern pools. Last, we give the continuous 
incremental updating algorithm.
A. Transaction Sequence Amalgamated Algorithm
Transaction Sequence Amalgamated algorithm, or TSA
algorithm for short, is an optimization technique for 
reducing the database size. Some important properties 
given as follows are used in TSA algorithm.
Definition 1: Item amount in a transaction is the count 
of presence of the same item in the transaction, and item 
quantity in a transaction is the count of all different items 
in the transaction.
Algorithm: FP-growth.
Input: Database, D ; minimum support threshold, min_sup.
Output: Set of frequent patterns.
Constructing phase of FP-tree
(1) scan D;
(2) collect F and sort F as L;
(3) create the root of a FP-tree and label as null;
(4) for each T?D, do{
(5) [p|P] = select and sort T according to the order in L;
(6) insert_tree ([p|P], T)
(7) next T;}
(8) return FP-tree
procedure insert_tree (P, N)
(1) if T has a child N such that N.item-name = p.item.name then N++
(2) else {create a new node N, and N.count = 1;
(3) N.parent = T;
(4) N.node-link = nodes with same item-name via node-link structure;
(5) if P?? then insert_tree (P, N)
(6) else return;}
Mining phase of a FP-tree
Procedure FP-growth (Tree, ?)
(1) if Tree contains a single path P then
(2) for each combination?generate pattern support = min_sup of nodes
(3) else for each a1, do {
(4) generate pattern?=ai??with support = ai.support;
(5) construct?conditional pattern base and?conditional FP-tree Tree?;
(6) if Tree??? then FP-growth (Tree?,?);}
63
Definition 2: Item amount constraint specifies that 
mining association rules is performed under the guidance 
of item amount provided in transaction database.
Definition 3: Transaction without item amount 
constraint is the transaction in which there is only item but 
no item amount. 
Definition 4: Transaction with item amount constraint 
is the transaction in which there is not only item but also 
item amount. 
Hypothesis: In a transaction, every item may have its 
amount. An item amount may be same to some items 
amount, but different with other items amount.
Definition 5: If a transaction database D1 is 
transformed into another transaction database D2 but their 
association relationship or frequent itemsets are 
consistence, the procedure of transformation is called 
equivalent transformation of transaction database, and the 
two databases are the equivalent database, denoted as D1
?D2
Definition 6: The item and its amount in a transaction 
can be denoted ItemID:Amount. That is said, in a 
transaction database, the i
.
th item of the TIDth transaction 
and its amount can be denoted Ii,TID:Ai,TID, where Ii,TID is 
the ith item of the TIDth transaction, and Ai,TID is the 
amount of the ith item in the TIDth
Definition 7: In a transaction database D, given two 
transactions, T1?D and T2?D. There are n items in 
transaction T1 and denoted T1 = {I
transaction, TID is the 
abbreviation of the transaction identifier.
1,T1:A1,T1, I2,T1:A2,T1, …,
In,T1:An,T1}, and there are m(m?n) items in transaction T2
and denoted T2= {I1,T2:A1,T2, I2,T2:A2,T2, …, Im,T2:Am,T2}. If 
all the items in transaction T2 must exist in transaction T1,
that is said, if ?I?{I1,T2, I2,T2, …, Im,T2 }, then must I?
{I1 T1, I2,T1, …, In,T1
Definition 8: In a transaction database D, given two 
transactions, T1?D and T2?D. There are n items in 
transaction T1 and denoted T1 = {I
}, called T2?T1, or T1?T2.
1,T1:A1,T1, I2,T1:A2,T1, …,
In,T1:An,T1}, and there are m(m<n) items in transaction T2 
and denoted T2= {I1,T2:A1,T2, I2,T2:A2,T2, …, Im,T2:Am,T2}.
In transaction T2, the items are sorted in descending 
amount. That is said, A1,T2?A2,T2?…?Am,T2, in T2. In 
transaction T1, the items are sorted according to 
descending amount, A1,T1?A2,T1?…?Am,T1?…?An,T1.
If the first m items in transaction T1 are the corresponding 
items in transaction T2, that is said, Ii,T1=Ii,T2
Definition 9: In a transaction database D, given two 
transactions, T1?D and T2?D. There are n items in 
transaction T1 and denoted T1 = {I
, i=1, 2, …, m,
we can say T1>T2.
1,T1:A1,T1, I2,T1:A2,T1, …,
In,T1:An,T1}, and there are n items in transaction T2 and 
denoted T2= {I1,T2:A1,T2, I2,T2:A2,T2, …, Im,T2:Am,T2}. If 
Ii,T1=Ii,T2, Ai,T1=Ai,T2
Definition 10: In a transaction database D, given two 
transactions, T1?D and T2?D. There are n items in 
transaction T1 and denoted T1 = {I
, i=1, 2, …, n, we can say T1=T2.
1,T1:A1,T1, I2,T1:A2,T1, …,
Im,T1:Am,T1, Im+1,T1:Am+1,T1, …, In,T1:An,T1}, and there are 
m(m? n) items in transaction T2 and denoted T2=
{I1,T2:A1,T2, I2,T2:A2,T2, …, Im,T2:Am,T2}. All the items are 
sorted according to descending amount in these two 
transactions. If the first m items in transaction T1 are same 
to the items in transaction T2 respectively, that is said, 
I1,T1 =I1,T2, I2,T1 =I2,T2, …, Im,T1 =Im,T2, the transaction T2
can be amalgamated into transaction T1, denoted 
T1’=T1+T2. The new transaction T1’ = {I1,T1:A1,T1’,
I2,T1:A2,T1’, …, Im,T1:Am,T1’, Im+1,T1:Am+1,T1, …, In,T1:An,T1}, 
where A1,T1’ = A1,T1 + A1,T2, A2,T1’ = A2,T1 + A2,T2, …, Am,T1’
= Am,T1 + Am,T2
Theorem 1: T1?D and T2?D, if T1?T2, T1?T2,
then T1’ = T1+T2. If T1’?D’, then D?D’. The theorem 
is also called amalgamated theorem.
.
According to Theorem 1, we can amalgamate the 
transactions in primitive transaction database so as to 
reduce the quantity of transactions in primitive transaction 
database. An algorithm called Transaction Sequence 
Amalgamated algorithm, or TSA algorithm for short, is 
proposed to reduce the quantity of transactions in 
primitive transaction database and is shown in Figure 2.  
In TSA algorithm, TSAD is the abbreviation of 
Transaction Sequence Amalgamated Database and stands 
for the amalgamated transaction database. The main idea 
of TSA algorithm is that sorting the transactions in the 
transaction database according to the quantity of items in
every transaction in descending order, and amalgamating 
these transactions in the sequence. 
Figure 2   The pseudo code of TSA algorithm 
B. Definition and Algorithm of Transaction Tree
Definition 11: A transaction tree, or T-tree for short, is 
a tree structure defined below. 
1) It consists of one root labeled as “null”, a set of item 
prefix subtrees as the children of the root, and a frequent 
item header table. 
2) Each node in the item prefix subtree consists of 
three fields: item name, count, and node link, where item 
name registers which item this node presents, count 
registers the number of items in transactions represented 
by the portion of the path reaching this node, and node 
link links to the next node in the T-tree carrying the same 
item name, or null if there is none. 
Algorithm: TSA.
Input: transaction database, D.
Output: sequence amalgamated database, TSAD.
Method:
(1) scan D; 
(2) sort transactions according toquantity of items in
(3) TSAD1 = T1;
(4) for ( k=2; k?n; k++ ) {
(5) for each transaction t?TSADk-1 {
(6) if ( t?Tk and t?Tk ) then t = t+Tk
(7) else TSADk = { TSADk-1, Tk }}};
(8) sort items according to descending amount in transaction
(9) return TSAD = TSADn
64
3) Each entry in the frequent item header table consists 
of two fields, item name and head of node link, which 
points to the first node in the T-tree carrying the item 
name.
The algorithm of constructing of transaction tree is
shown in Figure 3. Note that, the difference between 
T-tree constructing algorithm and FP-tree constructing 
algorithm is the order. 
Figure 3  The pseudo code of T-tree constructing algorithm
C. Candidate Pattern Pools
Candidate pattern pools include all of the candidate 
itemsets. Candidate pattern pools consist of two types of 
pools. One is the winner pattern pool, and another is the 
loser pattern pool. The definitions about the pattern pools 
are given as follows.
Definition 12: Candidate pattern pool is the set of the 
candidate itemsets. 
Definition 13: Winner pattern pool is the set of 
frequent itemsets. 
Definition 14: Loser pattern pool is the set of 
non-frequent itemsets. 
D.Continuous incremental updating algorithm
Let WP be the set of frequent itemsets in the winner 
pattern pool, LP is the set of non-frequent itemsets in the 
loser pattern pool, s be the minimum support, OD be the 
number of transactions in the old ODB, d be the number of 
transactions in an increment db, and ND be the number of 
transactions in the new NDB, where NDB=ODB?db,
ND=OD+d.
An itemset I is the member of the winner pattern pool 
in the ODB database if I.support?shOD, and an itemset 
I is the member of the winner pattern pool in the NDB
database if I.support?shND.
Lemma 1: An itemsets I which is the member of 
winner pattern pool in the ODB is a loser in the NDB if 
and only if I.supportNDB<shND.
Lemma 2: An itemsets I which is the member of 
winner pattern pool in the ODB is still a winner in the 
NDB if I.supportdb?shd.
Lemma 3: An itemsets I which is the member of loser 
pattern pool in the ODB is a winner in the NDB only if 
I.supportdb?shd.
Lemma 4: An itemsets I which is the member of loser 
pattern pool in the ODB is still a loser in the NDB if and 
only if I.supportdb<shd.
The Continuous Incremental Updating algorithm, CIU
algorithm for short, is described in Figure 4.
Figure 4   The pseudo code of CIU algorithm
Algorithm: Constructing of Transaction Tree or T-tree.
Input: D and min_sup.
Output: T-tree.
Method:
(1) amalgamate transactions by TSA algorithm;
(2) create the root of a T-tree and label as null;
(3) for each T?D, do{
(4) [p|P] = select and sort T according toorder;
(5) insert_tree ([p|P], T)
(6) next T;}
(7) return T-tree
procedure insert_tree (P, N)
(1) if T has N, N.item-name = p.item.name, N=N+item.amount
(2) else {create a new node N, and N.count = item.amount;
(3) N.parent = T;
(4) N.node-link = nodes with same item-name node-link structure;
(5) if P?? then call insert_tree (P, N)
(6) else return;}
Algorithm: CIU.
Input: (1) ODB; (2) OWP, ODB; (3) OLP; (4) db; (5) s
Output: (1) NDB; (2) NWP; and (3) NLP
Method:
(1) amalgamate transactions in db by TSA algorithm;
(2) constructing of T-tree in db;
(3) mining T-tree by FP-growth(tree, ?);
(4) for each itemset I in db, do {
(5) If I.supportdb?s?d then{
(6)    If I?OWP then {
(7)        OWP=OWP?I;
(8)        I.supportNDB=I.supportODB+I.supportdb;
(9)        NWP=NWP+I};
(10)    If I?OLP then {
(11)       OLP=OLP?I;
(12)       I.supportNDB=I.supportODB+I.supportdb;
(13)       If I.supportNDB?s?ND then NWP=NWP+I
(14)       else NLP=NLP+I};
(15)    If I ?OWP?OLP then {
(16)       I.supportNDB=I.supportdb;
(17)       if I.supportdb?s?ND then NWP=NWP+I
(18)       else NLP=NLP+I}};
(19) else {
(20)    If I?OLP then {
(21)       OLP=OLP?I;
(22)       I.supportNDB=I.supportODB+I.supportdb;
(23)       NLP=NLP+I};
(24)    If I?OWP then {
(25)       OWP=OWP?I;
(26)       I.supportNDB=I.supportODB+I.supportdb;
(27)       if I.supportdb?s?ND then NWP=NWP+I
(28)       else NLP=NLP+I};
(29)    If I ?OWP?OLP then {
(30)       I.supportNDB=I.supportdb;
(31)       NLP=NLP+I}};
(32) for each itemset I in OWP do{
(33) if I.supportODB?s?ND then NWP=NWP+I
(34) else NLP=NLP+I};
(35) NLP=NLP+OLP;
(36) return: NDB=ODB+db, NWP and NLP.
65
IV. PERFORMANCE STUDY
In this section, we present a performance comparison 
of CIU algorithm and FP-growth algorithm. 
The data sets that we used for our experiments are 
generated randomly. Figure 5 shows the results of test of 
run time. In our experiments, there are 50K transactions in 
primitive database. The run time shown in the figure is the 
incremental run time. The figure shows that the 
incremental run time can be reduced down by about 
one-half in the CIU algorithm, and the gap grows wider 
when the number of incremental transactions grows up.
Figure 5 Run time with incremental transactions
V. CONCLUSIONS
In this paper, we have investigated the problem of 
continuous incremental updating in large databases. The 
contributions of this paper are summarized here: 1) We 
have proposed an optimization technique for reducing the 
database size during the update process. 2) We have give 
the definition and algorithm of transaction tree T-tree. The 
order of items in every transaction in T-tree is different 
from that in FP-tree. 3) We have proposed a continuous 
incremental algorithm, or CIU algorithm for short. 4) We 
have implemented the CIU algorithm, and studied its 
performance in comparison with FP-growth algorithm in 
large databases. 
ACKNOWLEDGEMENT
This research was supported by National Natural 
Science Foundation of China 70971004.
REFERENCES
[1]R. Agrawal, T. Imielinski, and A. Swami, “Mining Association Rules 
between Sets of Items in Large Databases,” Proc. ACM-SIGMOD 
Int’l. Conf. Management of Data, Washington, USA, May 1993, pp.
207-216.
[2]R. Agrawal and R. Srikant, “Fast Algorithms for Mining Association 
Rules,” Proc. Int’l. Conf. Very Large Databases, Santiago, Chile, 
1994, pp. 487-499.
[3]S. Brin, R. Motwani, J. D. Ullman, and S. Tsur, “Dynamic Itemset 
Counting and Implication Rules for Market Basket Analysis,” Proc. 
ACM-SIGMOD Int’l. Conf. Management of Data, Tucson, USA, 
1997, pp. 255-264.
[4]G. Chang, M. J. Healey, J. A. M. McHugh, and J. T. L. Wang,
“Mining the World Wide Web: An Information Search Approach,”
Boston, USA: Kluwer Academin Publishers, 2001.
[5]D. W. Cheung, J. Han, V. T. Ng, and C. Y. Wong, “Maintenance of 
Discovered Association Rules in Large Databases: an Incremental 
Updating Technique,” Proc. Int’l. Conf. Data Engineering, New 
Orleans, USA, 1996, pp. 106-114.
[6]U. Fayyad, G. G. Grinstein, and A. Wierse, Information Visualization 
in Data Mining and Knowledge Discovery, San Francisco, USA: 
Morgan Kaufmann Publishers, 2001.
[7]U. Fayyad, G. Piatetsky-Shapiro, P. Smyth, and R. Uthurusamy, 
Advances in Knowledge Discovery and Data Mining. Cambridge, 
USA: MIT Press, 1996.
[8]U. Fayyad and R. Uthurusamy, Proc. Int’l. Conf. Knowledge 
Discovery and Data Mining. Montreal, Canada: AAAI Press, 1995.
[9]J. Han and Y. Fu, “Discovery of Multiple-level Association Rules 
from Large Databases,” Proc. Int’l. Conf. Very Data Bases, Zurich, 
Switzerland, 1995, pp. 420-431.
[10]J. Han and M. Kamber, Data Mining: Concepts and Techniques. 
San Francisco, USA: Morgan Kaufmann Publishers, 2001.
[11]J. Han, J. Pei, and Y. Yin. 2000, “Mining Frequent Patterns without 
Candidate Generation,” Proc. ACM-SIGMOD Int’l. Conf. 
Management of Data, Dalllax, USA, 2000, pp. 1-12.
[12]S. D. Lee, D. W. Cheung, and B. Kao, “Is Sampling Useful in Data 
Mining? A Case in the Maintenance of Discovered Association 
Rules,” Data Mining and Knowledge Discovery, vol. 2, 1998, pp.
225-262.
[13]J. S. Park, M. S. Chen, and P. S. Yu, “An Effective Hash-based 
Algorithm for Mining Association Rules,” Proc. ACM-SIGMOD Int’l.
Conf. Management of Data, San Jose, USA, 1995, pp. 175-186.
[14]G. Piatetsky-Shapiro, and  W. J. Frawley, Knowledge Discovery in 
Databases. Cambridge, USA: AAAI/MIT Press, 1991.
[15]A. Savasere, E. Omiecinski, and S. Navathe, “An Efficient 
Algorithm for Mining Association Rules in Large Databases,” Proc. 
Int’l. Conf. Very Large Data Bases, Zurich, Swiitzerland, 1995, pp.
432-443.
[16]H. Toivonen, “Sampliing Large Databases for Association Rules,”
Proc. Int’l. Conf. Very Large Data Bases, Bombay, India, 1996, pp.
134-145.
[18] J. M. Zaki, “Mining Non-Redundant Association Rules,” Data 
Mining and Knowledge Discovery, vol. 9, 2004, pp. 223–248.
[19] G. Li and H.J. Hamilton, “Basic association rules,” Proc. 4th SIAM 
Int’l. Conf. on Data Mining (SDM’04), Orlando, 2004.
[20] B. Liu, K. Zhao, B. Jeffreyer, and W. Xiao, “Rule Interestingness 
Analysis Using OLAP Operations,” Proc. 12th ACM SIGKDD Int’l.
Conf. on Knowledge Discovery and Data Mining (KDD’06),
Philadelphia, Pennsylvania, USA , August 20–23, 2006, pp. 297-306.
Number of incremental transactions
In
cr
em
en
ta
l r
un
 ti
m
e(
se
c.
)
FP-growth 
CIU 
66
